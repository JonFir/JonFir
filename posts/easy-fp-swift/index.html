<!doctype html><html lang=ru dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>Функциональный Swift — это просто | JonFir</title>
<meta name=keywords content="FP,Swift,iOS">
<meta name=description content="Быстрое и простое погружение в ФП на swift">
<meta name=author content="Евгений Елчев">
<link rel=canonical href=https://jonfir.github.io/posts/easy-fp-swift/>
<link crossorigin=anonymous href=/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css integrity="sha256-yIlj/i15RiAA/Q+xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://jonfir.github.io/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://jonfir.github.io/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=https://jonfir.github.io/favicon-32x32.png>
<link rel=apple-touch-icon href=https://jonfir.github.io/apple-touch-icon.png>
<link rel=mask-icon href=https://jonfir.github.io/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.91.2">
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript><meta property="og:title" content="Функциональный Swift — это просто">
<meta property="og:description" content="Быстрое и простое погружение в ФП на swift">
<meta property="og:type" content="article">
<meta property="og:url" content="https://jonfir.github.io/posts/easy-fp-swift/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2019-10-29T14:41:24+07:00">
<meta property="article:modified_time" content="2019-10-29T14:41:24+07:00"><meta property="og:site_name" content="JonFir">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="Функциональный Swift — это просто">
<meta name=twitter:description content="Быстрое и простое погружение в ФП на swift">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://jonfir.github.io/posts/"},{"@type":"ListItem","position":3,"name":"Функциональный Swift — это просто","item":"https://jonfir.github.io/posts/easy-fp-swift/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Функциональный Swift — это просто","name":"Функциональный Swift — это просто","description":"Быстрое и простое погружение в ФП на swift","keywords":["FP","Swift","iOS"],"articleBody":"В статьях о функциональном программировании много пишут о том, как ФП подход улучшает разработку: код становится легко писать, читать, разбивать на потоки и тестировать, построить плохую архитектуру невозможно~~, а волосы становятся мягкими и шелковистыми~~.\nНедостаток один — высокий порог входа. Пытаясь разобраться в ФП, я столкнулся с огромным количеством теории, функторами, монадами, теорией категорий и алгебраическими типами данных. А как применять ФП на практике, было неясно. Кроме того, примеры приводились на незнакомых мне языках — хаскеле и скале.\nТогда я решил разобраться в ФП самого начала. Разобрался и рассказал на codefest о том, что ФП — это на самом деле просто, что мы уже им пользуемся в Swift и можем пользоваться еще эффективнее.\nФункциональное программирование: чистые функции и отсутствие состояний Определить, что означает писать в той или иной парадигме — нелегкая задача. Парадигмы формируются десятилетиями людьми с разным видением, воплощаются в языках с непохожими подходами, обрастают инструментами. Эти инструменты и подходы считаются неотъемлемой частью парадигм, но на самом деле ими не являются.\nНапример, считается, что объектно-ориентированное программирование стоит на трех китах — наследование, инкапсуляция и полиморфизм. Но инкапсуляция и полиморфизм реализуется на функциях с той же легкостью, что и на объектах. Или замыкания — они родились в чистых функциональных языках, но так давно перекочевали в промышленные языки, что перестали ассоциироваться с ФП. Монады тоже пробираются в промышленные языки, но пока не утратили принадлежность к условному хаскелю в умах людей.\nВ итоге получается, что невозможно четко определить, что конкретно представляет из себя та или иная парадигма. Я в очередной раз столкнулся с этим на codefest 2019, где все эксперты ФП, говоря о функциональной парадигме, называли разные вещи.\nЛично мне понравилось определение из вики:\n«Функциона́льное программи́рование — раздел дискретной математики и парадигма программирования, в которой процесс вычисления трактуется как вычисление значений функций в математическом понимании последних (в отличие от функций как подпрограмм в процедурном программировании)».\nЧто такое математическая функция? Это функция, результат которой зависит только от данных, к которым она применена.\nПример математической функции в четыре строки кода выглядит так:\nfunc summ(a: Int, b: Int) - Int { return a + b } let x = summ(a: 2, b: 3) Вызывая функцию summ с входными аргументами 2 и 3, получим 5. Этот результат неизменен. Поменяйте программу, поток, место исполнения — результат останется прежним.\nА нематематическая функция — это когда где-то объявлена глобальная переменная.\nvar z = 5 Функция суммирования теперь складывает входные аргументы и значение z.\nfunc summ(a: Int, b: Int) - Int { return a + b + z } let x = summ(a: 2, b: 3) Добавилась зависимость от глобального состояния. Теперь нельзя однозначно предсказать значение x. Оно будет постоянно меняться в зависимости от того, когда была вызвана функция. Вызовем функцию 10 раз подряд, и каждый раз можем получить разный результат.\nЕще один вариант нематематической функции:\nfunc summ(a: Int, b: Int) - Int { z = b - a return a + b } Помимо возврата суммы входных аргументов, функция меняет глобальную переменную z. Эта функция имеет сайд-эффект.\nВ функциональном программировании есть специальный термин для математических функций — чистые функции. Чистая функция — это такая функция, которая для одного и того же набора входных значений возвращает одинаковый результат и не обладает побочными эффектами.\nЧистые функции — краеугольный камень ФП, все остальное уже вторично. Предполагается, что, следуя этой парадигме, используем только их. А если никак не работать с глобальными или изменяемыми состояниями, то их и не будет в приложении.\nКлассы и структуры в функциональной парадигме Изначально, я думал, что ФП — это только про функции, а классы и структуры используются только в ООП. Но оказалось, классы тоже вписываются в концепцию ФП. Только и они должны быть, скажем так, «чистыми».\n«Чистый» класс — класс, все методы которого являются чистыми функциями, а свойства неизменяемы. (Это неофициальный термин, придуман во время подготовки к докладу).\nВзглянем на такой класс:\nclass User { let name: String let surname: String let email: String func getFullname() - String { return name + \" \" + surname } } Его можно рассматривать как инкапсуляцию данных…\nclass User { let name: String let surname: String let email: String } и функций по работе с ними.\nfunc getFullname() - String { return name + \" \" + surname } С точки зрения ФП, использование класса User ничем не отличается от работы с примитивами и функциями.\nОбъявим значение — пользователя Ваню.\nlet ivan = User( name: \"Иван\", surname: \"Иванов\", email: \"ivanov@example.com\" ) Применим к нему функцию getFullname.\nlet fullName = ivan.getFullname() В результате получим новое значение — полное имя пользователя. Так как изменить параметры свойства ivan нельзя, результат вызова getFullname неизменен.\nКонечно внимательный читатель может сказать: «Постой-ка, метод getFullname возвращает результат на основе глобальных для него значений — свойств класса, а не аргументов». Но на самом деле метод — это просто функция, в которую в качестве аргумента передается объект.\nSwift даже поддерживает эту запись в явном виде:\nlet fullName = User.getFullname(ivan)() Если же нам понадобиться изменить какое-то значение у объекта, например email, то придется создавать новый объект. Это можно делать соответствующим методом.\nclass User { let name: String let surname: String let email: String func change(email: String) - User { return User(name: name, surname: surname, email: email) } } let newIvan = ivan.change(email: \"god@example.com\") Функциональные атрибуты в Swift Я уже писал о том, что многие инструменты, реализации и подходы, считающиеся частью той или иной парадигмы, на самом деле могут применяться и в других парадигмах. Например, частью ФП считаются монады, алгебраические типы данных, автоматический вывод типов, строгая типизация, зависимые типы, проверка корректности программы во время компиляции. Но многие из этих инструментов мы можем найти и в Swift.\nСтрогая типизация и вывод типов — часть Swift. Их не нужно понимать или вводить в проект, они просто у нас есть.\nЗависимых типов нет, хотя я бы не отказался от проверки компилятором строки, что она email, массива, что он не пустой, словаря, что он содержит ключ «apple». Кстати, в Haskell зависимых типов тоже нет.\nАлгебраические типы данных имеются, и это крутая, но сложная для понимания математическая штука. Прелесть в том, что ее не надо понимать математически, чтобы использовать. Например Int, enum, Optional, Hashable — это алгебраические типы. И если Int есть во многих языках, а Protocol есть и в Objective-C, то enum со связанными значениями, протоколы с дефолтной реализацией и ассоциативными типами есть далеко не везде.\nПроверку корректности во время компиляции часто упоминают, говоря о таких языках, как rust или haskell. Подразумевается, что язык настолько выразителен, что позволяет описать все краевые случаи так, чтобы их проверил компилятор. А значит, если программа скомпилировалась, то она обязательно будет работать. Никто не спорит, что она может содержать ошибки в логике, потому что вы неправильно отфильтровали данные для показа пользователю. Но она не будет падать, потому что вы не получили данные из БД, сервер вернул вам не тот ответ, на который вы рассчитывали, или пользователь ввел дату своего рождения строкой, а не числом.\nНе могу сказать, что компиляция swift кода может отловить все баги: например, утечку памяти допустить легко. Но строгая типизация и Optional хорошо защищают от множества глупых ошибок. Главное — ограничить принудительное извлечение.\nМонады: не часть парадигмы ФП, а инструмент (необязательный) Довольно часто ФП и монады используются в одном и том же приложении. Одно время я даже думал, что монады и есть функциональное программирование. Когда же я их понял (но это не точно), то сделал несколько выводов:\n они несложные; они удобные; понимать их необязательно, достаточно уметь применять; без них легко можно обойтись.  В Swift уже есть две стандартные монады — Optional и Result. Обе нужны для борьбы с сайд-эффектами. Optional защищает от возможного nil. Result — от различных исключительных ситуаций.\nРассмотрим на примере, доведенном до абсурда. Пусть у нас есть функции, возвращающие целое число из базы данных и от сервера. Вторая может вернуть nil, но мы используем неявное извлечение получая поведение времен Objective-C.\nfunc getIntFromDB() - Int func getIntFromServer() - Int! Продолжаем игнорировать Optional и реализуем функцию для суммирования этих чисел.\nfunc summInts() - Int! { let intFromDB = getIntFromDB() let intFromServer = getIntFromServer()! let summ = intFromDB + intFromServer return summ } Вызываем итоговую функцию и используем результат.\nlet result = summInts() print(result) Сработает ли этот пример? Ну, он определенно скомпилируется, а вот получим мы креш во время выполнения или нет — никому неизвестно. Этот код хорош, он отлично показывает наши намерения (нам необходима сумма каких-то двух чисел) и при этом не содержит ничего лишнего. Но он опасен. Поэтому так пишут только джуниоры и уверенные в себе люди.\nИзменим пример, сделав его безопасным.\nfunc getIntFromDB() - Int func getIntFromServer() - Int? func summInts() - Int? { let intFromDB = getIntFromDB() let intFromServer = getIntFromServer() if let intFromServer = intFromServer { let summ = intFromDB + intFromServer return summ } else { return nil } } if let result = summInts() { print(result) } Этот код хорош, он безопасен. Используя явное извлечение, мы защитились от возможного nil. Но он стал громоздким, и среди безопасных проверок уже сложно разглядеть наше намерение. Нам все еще необходима сумма каких-то двух чисел, а не проверки безопасности.\nНа этот случай у Optional есть метод map, доставшийся ему от типа Maybe из Haskell. Применим его, и пример изменится.\nfunc getIntFromDB() - Int func getIntFromServer() - Int? func summInts() - Int? { let intFromDB = getIntFromDB() let intFromServer = getIntFromServer() return intFromServer.map { x in x + intFromDB } } if let result = summInts() { print(result) } Или еще компактнее.\nfunc getIntFromDB() - Int func getintFromServer() - Int? func summInts() - Int? { return getintFromServer().map { $0 + getIntFromDB() } } if let result = summInts() { print(result) } Мы использовали map, чтобы преобразовать intFromServer в необходимый нам результат без извлечения.\nМы избавились от проверки внутри summInts, но оставили ее на верхнем уровне. Это сделано намеренно, так как в конце цепочки вычислений мы должны выбрать способ обработки отсутствия результата.\nИзвлечь\nif let result = summInts() { print(result) } Использовать значение по умолчанию\nprint(result ?? 0) Или вывести предупреждение если, данные не получены.\nif let result = summInts() { print(result) } else { print(\"Ошибка\") } Теперь код в примере не содержит лишнего, как в первом примере, и безопасен, как во втором.\nНо map не всегда работает так, как нужно\nlet a: String? = \"7\" let b = a.map { Int($0) } type(of: b)//Optional Если в map передать функцию, результат которой опционален, мы получим двойной Optional. Но нам не нужна двойная защита от nil. Достаточно одной. Решить проблему позволяет метод flatMap, это аналог map с одним отличием, он разворачивает матрешки.\nlet a: String? = \"7\" let b = a.flatMap { Int($0) } type(of: b)//Optional. Еще один пример, где map и flatMap не очень удобно использовать.\nlet a: Int? = 3 let b: Int? = 7 let c = a.map { $0 + b! } Что, если функция принимает два аргумента и они оба опциональные? Конечно, у ФП есть решение — это аппликативный функтор и каррирование. Но эти инструменты довольно неуклюже смотрятся без использования специальных операторов, которых нет в нашем языке, а писать кастомные операторы считается дурным тоном. Поэтому рассмотрим более интуитивный способ: напишем специальную функцию.\n@discardableResult func perform( _ transform: (U, Z) throws - Result, _ optional1: U?, _ optional2: Z?) rethrows - Result? { guard let optional1 = optional1, let optional2 = optional2 else { return nil } return try transform(optional1, optional2) } Она принимает в качестве аргументов два опциональных значения и функцию с двумя аргументами. Если оба опционала имеют значения, к ним применяется функция. Теперь мы можем работать с несколькими опционалами, не разворачивая их.\nlet a: Int? = 3 let b: Int? = 7 let result = perform(+, a, b) У второй монады, Result, тоже имеются методы map и flatMap. А значит, с ней можно работать точно так же.\nfunc getIntFromDB() - Int func getIntFromServer() - Resultfunc summInts() - Result{ let intFromDB = getIntFromDB() let intFromServer = getIntFromServer() return intFromServer.map { x in x + intFromDB } } if case .success(let result) = summInts() { print(result) } Собственно, это и роднит монады между собой — возможность работать со значением внутри контейнера, не извлекая его. На мой взгляд, это делает код лаконичнее. Но если вам не нравится, просто используйте явные извлечения, это не противоречит парадигме ФП.\nПример: сокращаем число «грязных» функций К сожалению, в реальных программах повсюду встречаются глобальные состояния и сайд-эффекты — сетевые запросы, источники данных, UI. И только чистыми функциями обойтись нельзя. Но это не значит, что ФП для нас полностью недоступно: мы можем постараться уменьшить число грязных функций, которых обычно очень много.\nРассмотрим небольшой пример, приближенный к продакшн-разработке. Построим UI, конкретно форму входа. Форма имеет некоторые ограничения:\n Логин не короче 3 символов Пароль не короче 6 символов Кнопка «Войти» активна, если оба поля валидны Цвет рамки поля отражает его состояние, черная — валидно, красная — не валидно  Код, описывающий эти ограничения, может выглядеть так:\nОбработка любого пользовательского ввода\n@IBAction func textFieldTextDidChange() { // 1. Зависимость от глобального стейта // 2. Явное извлечение guard let login = loginView.text, let password = passwordView.text else { // 3. Сайд-эффект  loginButton.isEnabled = false return } let loginIsValid = login.count  constants.loginMinLenght if loginIsValid { // 4. Сайд-эффект loginView.layer.borderColor = constants.normalColor } let passwordIsValid = password.count  constants.passwordMinLenght if passwordIsValid { // 5. Сайд-эффект passwordView.layer.borderColor = constants.normalColor } // 6. Сайд-эффект loginButton.isEnabled = loginIsValid \u0026\u0026 passwordIsValid } Обработка завершения ввода логина:\n@IBAction func loginDidEndEdit() { let color: CGColor // 1. Зависмость от глобального стейта // 2. Явное извлечение if let login = loginView.text, login.count  3 { color = constants.normalColor } else { color = constants.errorColor } // 3. Сайд эфект loginView.layer.borderColor = color } Обработка завершения ввода пароля:\n@IBAction func passwordDidEndEdit() { let color: CGColor // 1. Зависимость от глобального стейта // 2. Явное извлечение if let password = passwordView.text, password.count  6 { color = constants.normalColor } else { color = constants.errorColor } // 3. Сайд-эффект passwordView.layer.borderColor = color } Нажатие на кнопку войти:\n@IBAction private func loginPressed() { // 1. Зависимость от глобального стейта // 2. Явное извлечение guard let login = loginView.text, let password = passwordView.text else { return } auth(login: login, password: password) { [weak self] user, error in if let user = user { /* успех */ } else if error is AuthError { guard let `self` = self else { return } // 3. Сайд-эффект self.passwordView.layer.borderColor = self.constants.errorColor // 4. Сайд-эффект self.loginView.layer.borderColor = self.constants.errorColor } else { /* Другие ошибки */ } } } Возможно, этот код не самый лучший, но в целом он неплох и работает. Правда, у него есть ряд проблем:\n 4 явных извлечения; 4 зависимости от глобального стейта; 8 сайд-эффектов; неочевидные конечные состояния; нелинейный флоу.  Главная проблема состоит в том, что нельзя просто взять и сказать, что происходит с нашим экраном. Глядя на один метод, мы видим, что он делает с глобальным стейтом, но не знаем, кто, где и когда еще трогает стейт. В итоге, чтобы разобраться в происходящем, надо найти все точки работы с вьюшками и понять, в каком порядке какие воздействия происходят. Удержать все это в голове очень сложно.\nЕсли процесс изменения состояния линейный, можно изучать его шаг за шагом, что снизит когнитивную нагрузку на программиста.\nПопробуем изменить пример, сделав его более функциональным.\nДля начала определим модель, описывающую текущее состояние экрана. Это позволит точно знать, какая информация необходима для работы.\nstruct LoginOutputModel { let login: String let password: String var loginIsValid: Bool { return login.count  3 } var passwordIsValid: Bool { return password.count  6 } var isValid: Bool { return loginIsValid \u0026\u0026 passwordIsValid } } Модель, описывающую изменения, применяемые к экрану. Она нужна, чтобы точно знать, что мы будем менять.\nstruct LoginInputModel { let loginBorderColor: CGColor? let passwordBorderColor: CGColor? let loginButtonEnable: Bool? let popupErrorMessage: String? } События, которые могут привести к новому состоянию экрана. Так мы точно будем знать, какие действия изменяют экран.\nenum Event { case textFieldTextDidChange case loginDidEndEdit case passwordDidEndEdit case loginPressed case authFailure(Error) } Теперь опишем главный метод изменения. Эта чистая функция на основе события текущего состояния собирает новое состояние экрана.\nfunc makeInputModel( event: Event, outputModel: LoginOutputModel?) - LoginInputModel { switch event { case .textFieldTextDidChange: let mapValidToColor: (Bool) - CGColor? = { $0 ? normalColor : nil } return LoginInputModel( loginBorderColor: outputModel .map { $0.loginIsValid } .flatMap(mapValidToColor), passwordBorderColor: outputModel .map { $0.passwordIsValid } .flatMap(mapValidToColor), loginButtonEnable: outputModel?.passwordIsValid ) case .loginDidEndEdit: return LoginInputModel(/**/) case .passwordDidEndEdit: return LoginInputModel(/**/) case .loginPressed: return LoginInputModel(/**/) case .authFailure(let error) where error is AuthError: return LoginInputModel(/**/) case .authFailure: return LoginInputModel(/**/) } } Самое важное в том, что этот метод единственный, кому позволено заниматься конструированием нового состояния — и он чистый. Его можно изучить шаг за шагом. Увидеть, как события преобразуют экран из точки А в точку Б. Если что-то сломается, то проблема точно здесь. И это легко тестировать.\nДобавим вспомогательное свойство для получения текущего состояния, это единственный метод, зависящий от глобального состояния.\nvar outputModel: LoginOutputModel? { return perform(LoginOutputModel.init, loginView.text, passwordView.text) } Добавим еще один «грязный» метод для создания сайд-эффектов изменения экрана.\nfunc updateView(_ event: Event) { let inputModel = makeInputModel(event: event, outputModel: outputModel) if let color = inputModel.loginBorderColor { loginView.layer.borderColor = color } if let color = inputModel.passwordBorderColor { passwordView.layer.borderColor = color } if let isEnable = inputModel.loginButtonEnable { loginButton.isEnabled = isEnable } if let error = inputModel.popupErrorMessage { showPopup(error) } } Хотя метод updateView и не является чистым, но это единственное место, где меняются свойства экрана. Первый и последний пункт в цепочке вычислений. И если что-то пошло не так, именно тут будет стоять брейкпоинт.\nОсталось только запустить преобразования в нужных местах.\n@IBAction func textFieldTextDidChange() { updateView(.textFieldTextDidChange) } @IBAction func loginDidEndEdit() { updateView(.loginDidEndEdit) } @IBAction func passwordDidEndEdit() { updateView(.passwordDidEndEdit) } Метод loginPressed вышел немного уникальным.\n@IBAction private func loginPressed() { updateView(.loginPressed) let completion: (Result) - Void = { [weak self] result in switch result { case .success(let user): /* успех */ case .failure(let error): self?.updateView(.authFailure(error)) } } outputModel.map { auth(login: $0.login, password: $0.password, completion: completion) } } Дело в том, что нажатие на кнопку «Войти» запускает две цепочки вычислений, что не запрещается.\nЗаключение До начала изучения ФП я делал сильный акцент на парадигмах программирования. Для меня было важно, чтобы код следовал ООП, я не любил статические функции или объекты без состояний, не писал глобальных функций.\nСейчас мне кажется, что все те вещи, что я считал частью той или иной парадигмы — довольно условны. Главное — это чистый, понятный код. Для достижения этой цели можно использовать все, что возможно: чистые функции, классы, монады, наследование, композиция, вывод типов. Все они хорошо уживаются вместе и делают код лучше — достаточно применять их к месту.\n","wordCount":"3030","inLanguage":"ru","datePublished":"2019-10-29T14:41:24+07:00","dateModified":"2019-10-29T14:41:24+07:00","author":{"@type":"Person","name":"Евгений Елчев"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://jonfir.github.io/posts/easy-fp-swift/"},"publisher":{"@type":"Organization","name":"JonFir","logo":{"@type":"ImageObject","url":"https://jonfir.github.io/favicon.ico"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://jonfir.github.io accesskey=h title="JonFir (Alt + H)">JonFir</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu>
<li>
<a href=https://jonfir.github.io/archives/ title=Архив>
<span>Архив</span>
</a>
</li>
<li>
<a href=https://jonfir.github.io/tags/ title=Теги>
<span>Теги</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<div class=breadcrumbs><a href=https://jonfir.github.io>Главная</a>&nbsp;»&nbsp;<a href=https://jonfir.github.io/posts/>Posts</a></div>
<h1 class=post-title>
Функциональный Swift — это просто
</h1>
<div class=post-description>
Быстрое и простое погружение в ФП на swift
</div>
<div class=post-meta><span title="2019-10-29 14:41:24 +0700 +07">октября 29, 2019</span>&nbsp;·&nbsp;15 мин&nbsp;·&nbsp;Евгений Елчев
</div>
</header> <div class=toc>
<details open>
<summary accesskey=c title="(Alt + C)">
<span class=details>Оглавление</span>
</summary>
<div class=inner><ul>
<li>
<a href=#%d1%84%d1%83%d0%bd%d0%ba%d1%86%d0%b8%d0%be%d0%bd%d0%b0%d0%bb%d1%8c%d0%bd%d0%be%d0%b5-%d0%bf%d1%80%d0%be%d0%b3%d1%80%d0%b0%d0%bc%d0%bc%d0%b8%d1%80%d0%be%d0%b2%d0%b0%d0%bd%d0%b8%d0%b5-%d1%87%d0%b8%d1%81%d1%82%d1%8b%d0%b5-%d1%84%d1%83%d0%bd%d0%ba%d1%86%d0%b8%d0%b8-%d0%b8-%d0%be%d1%82%d1%81%d1%83%d1%82%d1%81%d1%82%d0%b2%d0%b8%d0%b5-%d1%81%d0%be%d1%81%d1%82%d0%be%d1%8f%d0%bd%d0%b8%d0%b9 aria-label="Функциональное программирование: чистые функции и отсутствие состояний">Функциональное программирование: чистые функции и отсутствие состояний</a></li>
<li>
<a href=#%d0%ba%d0%bb%d0%b0%d1%81%d1%81%d1%8b-%d0%b8-%d1%81%d1%82%d1%80%d1%83%d0%ba%d1%82%d1%83%d1%80%d1%8b-%d0%b2-%d1%84%d1%83%d0%bd%d0%ba%d1%86%d0%b8%d0%be%d0%bd%d0%b0%d0%bb%d1%8c%d0%bd%d0%be%d0%b9-%d0%bf%d0%b0%d1%80%d0%b0%d0%b4%d0%b8%d0%b3%d0%bc%d0%b5 aria-label="Классы и структуры в функциональной парадигме">Классы и структуры в функциональной парадигме</a></li>
<li>
<a href=#%d1%84%d1%83%d0%bd%d0%ba%d1%86%d0%b8%d0%be%d0%bd%d0%b0%d0%bb%d1%8c%d0%bd%d1%8b%d0%b5-%d0%b0%d1%82%d1%80%d0%b8%d0%b1%d1%83%d1%82%d1%8b-%d0%b2-swift aria-label="Функциональные атрибуты в Swift">Функциональные атрибуты в Swift</a></li>
<li>
<a href=#%d0%bc%d0%be%d0%bd%d0%b0%d0%b4%d1%8b-%d0%bd%d0%b5-%d1%87%d0%b0%d1%81%d1%82%d1%8c-%d0%bf%d0%b0%d1%80%d0%b0%d0%b4%d0%b8%d0%b3%d0%bc%d1%8b-%d1%84%d0%bf-%d0%b0-%d0%b8%d0%bd%d1%81%d1%82%d1%80%d1%83%d0%bc%d0%b5%d0%bd%d1%82-%d0%bd%d0%b5%d0%be%d0%b1%d1%8f%d0%b7%d0%b0%d1%82%d0%b5%d0%bb%d1%8c%d0%bd%d1%8b%d0%b9 aria-label="Монады: не часть парадигмы ФП, а инструмент (необязательный)">Монады: не часть парадигмы ФП, а инструмент (необязательный)</a></li>
<li>
<a href=#%d0%bf%d1%80%d0%b8%d0%bc%d0%b5%d1%80-%d1%81%d0%be%d0%ba%d1%80%d0%b0%d1%89%d0%b0%d0%b5%d0%bc-%d1%87%d0%b8%d1%81%d0%bb%d0%be-%d0%b3%d1%80%d1%8f%d0%b7%d0%bd%d1%8b%d1%85-%d1%84%d1%83%d0%bd%d0%ba%d1%86%d0%b8%d0%b9 aria-label="Пример: сокращаем число «грязных» функций">Пример: сокращаем число «грязных» функций</a></li>
<li>
<a href=#%d0%b7%d0%b0%d0%ba%d0%bb%d1%8e%d1%87%d0%b5%d0%bd%d0%b8%d0%b5 aria-label=Заключение>Заключение</a>
</li>
</ul>
</div>
</details>
</div>
<div class=post-content><p>В статьях о функциональном программировании много пишут о том, как ФП подход улучшает разработку: код становится легко писать, читать, разбивать на потоки и тестировать, построить плохую архитектуру невозможно~~, а волосы становятся мягкими и шелковистыми~~.</p>
<p>Недостаток один — высокий порог входа. Пытаясь разобраться в ФП, я столкнулся с огромным количеством теории, функторами, монадами, теорией категорий и алгебраическими типами данных. А как применять ФП на практике, было неясно. Кроме того, примеры приводились на незнакомых мне языках — хаскеле и скале.</p>
<p>Тогда я решил разобраться в ФП самого начала. Разобрался и <a href=https://2019.codefest.ru/lecture/1413>рассказал на codefest</a> о том, что ФП — это на самом деле просто, что мы уже им пользуемся в Swift и можем пользоваться еще эффективнее.</p>
<h2 id=функциональное-программирование-чистые-функции-и-отсутствие-состояний>Функциональное программирование: чистые функции и отсутствие состояний<a hidden class=anchor aria-hidden=true href=#функциональное-программирование-чистые-функции-и-отсутствие-состояний>#</a></h2>
<p>Определить, что означает писать в той или иной парадигме — нелегкая задача. Парадигмы формируются десятилетиями людьми с разным видением, воплощаются в языках с непохожими подходами, обрастают инструментами. Эти инструменты и подходы считаются неотъемлемой частью парадигм, но на самом деле ими не являются.</p>
<p>Например, считается, что объектно-ориентированное программирование стоит на трех китах — наследование, инкапсуляция и полиморфизм. Но инкапсуляция и полиморфизм реализуется на функциях с той же легкостью, что и на объектах. Или замыкания — они родились в чистых функциональных языках, но так давно перекочевали в промышленные языки, что перестали ассоциироваться с ФП. Монады тоже пробираются в промышленные языки, но пока не утратили принадлежность к условному хаскелю в умах людей.</p>
<p>В итоге получается, что невозможно четко определить, что конкретно представляет из себя та или иная парадигма. Я в очередной раз столкнулся с этим на codefest 2019, где все эксперты ФП, говоря о функциональной парадигме, называли разные вещи.</p>
<p>Лично мне понравилось определение из вики:</p>
<p>«Функциона́льное программи́рование — раздел дискретной математики и парадигма программирования, в которой процесс вычисления трактуется как вычисление значений функций в математическом понимании последних (в отличие от функций как подпрограмм в процедурном программировании)».</p>
<p>Что такое математическая функция? Это функция, результат которой зависит только от данных, к которым она применена.</p>
<p>Пример математической функции в четыре строки кода выглядит так:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>summ</span>(a: Int, b: Int) -&gt; Int {
    <span style=color:#66d9ef>return</span> a <span style=color:#f92672>+</span> b
}
<span style=color:#66d9ef>let</span> x = summ(a: <span style=color:#ae81ff>2</span>, b: <span style=color:#ae81ff>3</span>)
</code></pre></div><p>Вызывая функцию summ с входными аргументами 2 и 3, получим 5. Этот результат неизменен. Поменяйте программу, поток, место исполнения — результат останется прежним.</p>
<p>А нематематическая функция — это когда где-то объявлена глобальная переменная.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>var</span> z = <span style=color:#ae81ff>5</span>
</code></pre></div><p>Функция суммирования теперь складывает входные аргументы и значение z.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>summ</span>(a: Int, b: Int) -&gt; Int {
    <span style=color:#66d9ef>return</span> a <span style=color:#f92672>+</span> b <span style=color:#f92672>+</span> z
}
<span style=color:#66d9ef>let</span> x = summ(a: <span style=color:#ae81ff>2</span>, b: <span style=color:#ae81ff>3</span>)
</code></pre></div><p>Добавилась зависимость от глобального состояния. Теперь нельзя однозначно предсказать значение x. Оно будет постоянно меняться в зависимости от того, когда была вызвана функция. Вызовем функцию 10 раз подряд, и каждый раз можем получить разный результат.</p>
<p>Еще один вариант нематематической функции:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>summ</span>(a: Int, b: Int) -&gt; Int {
    z = b <span style=color:#f92672>-</span> a
    <span style=color:#66d9ef>return</span> a <span style=color:#f92672>+</span> b
}
</code></pre></div><p>Помимо возврата суммы входных аргументов, функция меняет глобальную переменную z. Эта функция имеет сайд-эффект.</p>
<p>В функциональном программировании есть специальный термин для математических функций — чистые функции. Чистая функция — это такая функция, которая для одного и того же набора входных значений возвращает одинаковый результат и не обладает побочными эффектами.</p>
<p>Чистые функции — краеугольный камень ФП, все остальное уже вторично. Предполагается, что, следуя этой парадигме, используем только их. А если никак не работать с глобальными или изменяемыми состояниями, то их и не будет в приложении.</p>
<h2 id=классы-и-структуры-в-функциональной-парадигме>Классы и структуры в функциональной парадигме<a hidden class=anchor aria-hidden=true href=#классы-и-структуры-в-функциональной-парадигме>#</a></h2>
<p>Изначально, я думал, что ФП — это только про функции, а классы и структуры используются только в ООП. Но оказалось, классы тоже вписываются в концепцию ФП. Только и они должны быть, скажем так, «чистыми».</p>
<p>«Чистый» класс — класс, все методы которого являются чистыми функциями, а свойства неизменяемы. (Это неофициальный термин, придуман во время подготовки к докладу).</p>
<p>Взглянем на такой класс:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>User</span> {
    <span style=color:#66d9ef>let</span> name: String
    <span style=color:#66d9ef>let</span> surname: String
    <span style=color:#66d9ef>let</span> email: String

    <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>getFullname</span>() -&gt; String {
        <span style=color:#66d9ef>return</span> name <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; &#34;</span> <span style=color:#f92672>+</span> surname
    }   
}
</code></pre></div><p>Его можно рассматривать как инкапсуляцию данных&mldr;</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>User</span> {
    <span style=color:#66d9ef>let</span> name: String
    <span style=color:#66d9ef>let</span> surname: String
    <span style=color:#66d9ef>let</span> email: String   
}
</code></pre></div><p>и функций по работе с ними.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>getFullname</span>() -&gt; String {
    <span style=color:#66d9ef>return</span> name <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; &#34;</span> <span style=color:#f92672>+</span> surname
}
</code></pre></div><p>С точки зрения ФП, использование класса User ничем не отличается от работы с примитивами и функциями.</p>
<p>Объявим значение — пользователя Ваню.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>let</span> ivan = User(
    name: <span style=color:#e6db74>&#34;Иван&#34;</span>,
    surname: <span style=color:#e6db74>&#34;Иванов&#34;</span>,
    email: <span style=color:#e6db74>&#34;ivanov@example.com&#34;</span>
)
</code></pre></div><p>Применим к нему функцию getFullname.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>let</span> fullName = ivan.getFullname()
</code></pre></div><p>В результате получим новое значение — полное имя пользователя. Так как изменить параметры свойства ivan нельзя, результат вызова getFullname неизменен.</p>
<p>Конечно внимательный читатель может сказать: «Постой-ка, метод getFullname возвращает результат на основе глобальных для него значений — свойств класса, а не аргументов». Но на самом деле метод — это просто функция, в которую в качестве аргумента передается объект.</p>
<p>Swift даже поддерживает эту запись в явном виде:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>let</span> fullName = User.getFullname(ivan)()
</code></pre></div><p>Если же нам понадобиться изменить какое-то значение у объекта, например email, то придется создавать новый объект. Это можно делать соответствующим методом.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>User</span> {
    <span style=color:#66d9ef>let</span> name: String
    <span style=color:#66d9ef>let</span> surname: String
    <span style=color:#66d9ef>let</span> email: String

    <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>change</span>(email: String) -&gt; User {
        <span style=color:#66d9ef>return</span> User(name: name, surname: surname, email: email)
    }    
}
<span style=color:#66d9ef>let</span> newIvan = ivan.change(email: <span style=color:#e6db74>&#34;god@example.com&#34;</span>)
</code></pre></div><h2 id=функциональные-атрибуты-в-swift>Функциональные атрибуты в Swift<a hidden class=anchor aria-hidden=true href=#функциональные-атрибуты-в-swift>#</a></h2>
<p>Я уже писал о том, что многие инструменты, реализации и подходы, считающиеся частью той или иной парадигмы, на самом деле могут применяться и в других парадигмах. Например, частью ФП считаются монады, алгебраические типы данных, автоматический вывод типов, строгая типизация, зависимые типы, проверка корректности программы во время компиляции. Но многие из этих инструментов мы можем найти и в Swift.</p>
<p>Строгая типизация и вывод типов — часть Swift. Их не нужно понимать или вводить в проект, они просто у нас есть.</p>
<p>Зависимых типов нет, хотя я бы не отказался от проверки компилятором строки, что она email, массива, что он не пустой, словаря, что он содержит ключ «apple». Кстати, в Haskell зависимых типов тоже нет.</p>
<p>Алгебраические типы данных имеются, и это крутая, но сложная для понимания математическая штука. Прелесть в том, что ее не надо понимать математически, чтобы использовать. Например Int, enum, Optional, Hashable — это алгебраические типы. И если Int есть во многих языках, а Protocol есть и в Objective-C, то enum со связанными значениями, протоколы с дефолтной реализацией и ассоциативными типами есть далеко не везде.</p>
<p>Проверку корректности во время компиляции часто упоминают, говоря о таких языках, как rust или haskell. Подразумевается, что язык настолько выразителен, что позволяет описать все краевые случаи так, чтобы их проверил компилятор. А значит, если программа скомпилировалась, то она обязательно будет работать. Никто не спорит, что она может содержать ошибки в логике, потому что вы неправильно отфильтровали данные для показа пользователю. Но она не будет падать, потому что вы не получили данные из БД, сервер вернул вам не тот ответ, на который вы рассчитывали, или пользователь ввел дату своего рождения строкой, а не числом.</p>
<p>Не могу сказать, что компиляция swift кода может отловить все баги: например, утечку памяти допустить легко. Но строгая типизация и Optional хорошо защищают от множества глупых ошибок. Главное — ограничить принудительное извлечение.</p>
<h2 id=монады-не-часть-парадигмы-фп-а-инструмент-необязательный>Монады: не часть парадигмы ФП, а инструмент (необязательный)<a hidden class=anchor aria-hidden=true href=#монады-не-часть-парадигмы-фп-а-инструмент-необязательный>#</a></h2>
<p>Довольно часто ФП и монады используются в одном и том же приложении. Одно время я даже думал, что монады и есть функциональное программирование. Когда же я их понял (но это не точно), то сделал несколько выводов:</p>
<ul>
<li>они несложные;</li>
<li>они удобные;</li>
<li>понимать их необязательно, достаточно уметь применять;</li>
<li>без них легко можно обойтись.</li>
</ul>
<p>В Swift уже есть две стандартные монады — Optional и Result. Обе нужны для борьбы с сайд-эффектами. Optional защищает от возможного nil. Result — от различных исключительных ситуаций.</p>
<p>Рассмотрим на примере, доведенном до абсурда. Пусть у нас есть функции, возвращающие целое число из базы данных и от сервера. Вторая может вернуть nil, но мы используем неявное извлечение получая поведение времен Objective-C.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>getIntFromDB</span>() -&gt; Int
<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>getIntFromServer</span>() -&gt; Int!
</code></pre></div><p>Продолжаем игнорировать Optional и реализуем функцию для суммирования этих чисел.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>summInts</span>() -&gt; Int! {
    <span style=color:#66d9ef>let</span> intFromDB = getIntFromDB()
    <span style=color:#66d9ef>let</span> intFromServer = getIntFromServer()<span style=color:#f92672>!</span>
    <span style=color:#66d9ef>let</span> summ = intFromDB <span style=color:#f92672>+</span> intFromServer
    <span style=color:#66d9ef>return</span> summ
}
</code></pre></div><p>Вызываем итоговую функцию и используем результат.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>let</span> result = summInts()
print(result)
</code></pre></div><p>Сработает ли этот пример? Ну, он определенно скомпилируется, а вот получим мы креш во время выполнения или нет — никому неизвестно. Этот код хорош, он отлично показывает наши намерения (нам необходима сумма каких-то двух чисел) и при этом не содержит ничего лишнего. Но он опасен. Поэтому так пишут только джуниоры и уверенные в себе люди.</p>
<p>Изменим пример, сделав его безопасным.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>getIntFromDB</span>() -&gt; Int
<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>getIntFromServer</span>() -&gt; Int?

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>summInts</span>() -&gt; Int? {
    <span style=color:#66d9ef>let</span> intFromDB = getIntFromDB()
    <span style=color:#66d9ef>let</span> intFromServer = getIntFromServer()

    <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> intFromServer = intFromServer {
        <span style=color:#66d9ef>let</span> summ = intFromDB <span style=color:#f92672>+</span> intFromServer
        <span style=color:#66d9ef>return</span> summ
    } <span style=color:#66d9ef>else</span> {
        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
    }
}

<span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> result = summInts() {
    print(result)
}
</code></pre></div><p>Этот код хорош, он безопасен. Используя явное извлечение, мы защитились от возможного nil. Но он стал громоздким, и среди безопасных проверок уже сложно разглядеть наше намерение. Нам все еще необходима сумма каких-то двух чисел, а не проверки безопасности.</p>
<p>На этот случай у Optional есть метод map, доставшийся ему от типа Maybe из Haskell. Применим его, и пример изменится.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>getIntFromDB</span>() -&gt; Int
<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>getIntFromServer</span>() -&gt; Int?

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>summInts</span>() -&gt; Int? {
    <span style=color:#66d9ef>let</span> intFromDB = getIntFromDB()
    <span style=color:#66d9ef>let</span> intFromServer = getIntFromServer()

    <span style=color:#66d9ef>return</span> intFromServer.map { x <span style=color:#66d9ef>in</span> x <span style=color:#f92672>+</span> intFromDB }
}

<span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> result = summInts() {
    print(result)
}
</code></pre></div><p>Или еще компактнее.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>getIntFromDB</span>() -&gt; Int
<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>getintFromServer</span>() -&gt; Int?

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>summInts</span>() -&gt; Int? {
    <span style=color:#66d9ef>return</span> getintFromServer().map { $0 <span style=color:#f92672>+</span> getIntFromDB() }
}

<span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> result = summInts() {
    print(result)
}
</code></pre></div><p>Мы использовали map, чтобы преобразовать intFromServer в необходимый нам результат без извлечения.</p>
<p>Мы избавились от проверки внутри summInts, но оставили ее на верхнем уровне. Это сделано намеренно, так как в конце цепочки вычислений мы должны выбрать способ обработки отсутствия результата.</p>
<p>Извлечь</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> result = summInts() {
    print(result)
}
</code></pre></div><p>Использовать значение по умолчанию</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift>print(result ?? <span style=color:#ae81ff>0</span>)
</code></pre></div><p>Или вывести предупреждение если, данные не получены.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> result = summInts() {
    print(result)
} <span style=color:#66d9ef>else</span> {
    print(<span style=color:#e6db74>&#34;Ошибка&#34;</span>)
}
</code></pre></div><p>Теперь код в примере не содержит лишнего, как в первом примере, и безопасен, как во втором.</p>
<p>Но map не всегда работает так, как нужно</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>let</span> a: String? = <span style=color:#e6db74>&#34;7&#34;</span>
<span style=color:#66d9ef>let</span> b = a.map { Int($0) }
type(of: b)<span style=color:#75715e>//Optional&lt;Optional&lt;Int&gt;&gt;</span>
</code></pre></div><p>Если в map передать функцию, результат которой опционален, мы получим двойной Optional. Но нам не нужна двойная защита от nil. Достаточно одной. Решить проблему позволяет метод flatMap, это аналог map с одним отличием, он разворачивает матрешки.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>let</span> a: String? = <span style=color:#e6db74>&#34;7&#34;</span>
<span style=color:#66d9ef>let</span> b = a.flatMap { Int($0) }
type(of: b)<span style=color:#75715e>//Optional&lt;Int&gt;.</span>
</code></pre></div><p>Еще один пример, где map и flatMap не очень удобно использовать.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>let</span> a: Int? = <span style=color:#ae81ff>3</span>
<span style=color:#66d9ef>let</span> b: Int? = <span style=color:#ae81ff>7</span>
<span style=color:#66d9ef>let</span> c = a.map { $0 <span style=color:#f92672>+</span> b! }
</code></pre></div><p>Что, если функция принимает два аргумента и они оба опциональные? Конечно, у ФП есть решение — это аппликативный функтор и каррирование. Но эти инструменты довольно неуклюже смотрятся без использования специальных операторов, которых нет в нашем языке, а писать кастомные операторы считается дурным тоном. Поэтому рассмотрим более интуитивный способ: напишем специальную функцию.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift>@discardableResult
<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>perform</span>&lt;Result, U, Z&gt;(
    <span style=color:#66d9ef>_</span> transform: (U, Z) <span style=color:#66d9ef>throws</span> -&gt; Result,
    <span style=color:#66d9ef>_</span> optional1: U?,
    <span style=color:#66d9ef>_</span> optional2: Z?) <span style=color:#66d9ef>rethrows</span> -&gt; Result? {

    <span style=color:#66d9ef>guard</span>
        <span style=color:#66d9ef>let</span> optional1 = optional1,
        <span style=color:#66d9ef>let</span> optional2 = optional2
        <span style=color:#66d9ef>else</span> {
            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
    }

    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>try</span> transform(optional1, optional2)
}
</code></pre></div><p>Она принимает в качестве аргументов два опциональных значения и функцию с двумя аргументами. Если оба опционала имеют значения, к ним применяется функция.
Теперь мы можем работать с несколькими опционалами, не разворачивая их.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>let</span> a: Int? = <span style=color:#ae81ff>3</span>
<span style=color:#66d9ef>let</span> b: Int? = <span style=color:#ae81ff>7</span>
<span style=color:#66d9ef>let</span> result = perform(<span style=color:#f92672>+</span>, a, b)
</code></pre></div><p>У второй монады, Result, тоже имеются методы map и flatMap. А значит, с ней можно работать точно так же.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>getIntFromDB</span>() -&gt; Int
<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>getIntFromServer</span>() -&gt; Result&lt;Int, ServerError&gt;

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>summInts</span>() -&gt; Result&lt;Int, ServerError&gt; {
    <span style=color:#66d9ef>let</span> intFromDB = getIntFromDB()
    <span style=color:#66d9ef>let</span> intFromServer = getIntFromServer()

    <span style=color:#66d9ef>return</span> intFromServer.map { x <span style=color:#66d9ef>in</span> x <span style=color:#f92672>+</span> intFromDB }
}

<span style=color:#66d9ef>if</span> <span style=color:#66d9ef>case</span> .success(<span style=color:#66d9ef>let</span> result) = summInts() {
    print(result)
}
</code></pre></div><p>Собственно, это и роднит монады между собой — возможность работать со значением внутри контейнера, не извлекая его. На мой взгляд, это делает код лаконичнее. Но если вам не нравится, просто используйте явные извлечения, это не противоречит парадигме ФП.</p>
<h2 id=пример-сокращаем-число-грязных-функций>Пример: сокращаем число «грязных» функций<a hidden class=anchor aria-hidden=true href=#пример-сокращаем-число-грязных-функций>#</a></h2>
<p>К сожалению, в реальных программах повсюду встречаются глобальные состояния и сайд-эффекты — сетевые запросы, источники данных, UI. И только чистыми функциями обойтись нельзя. Но это не значит, что ФП для нас полностью недоступно: мы можем постараться уменьшить число грязных функций, которых обычно очень много.</p>
<p>Рассмотрим небольшой пример, приближенный к продакшн-разработке. Построим UI, конкретно форму входа. Форма имеет некоторые ограничения:</p>
<ol>
<li>Логин не короче 3 символов</li>
<li>Пароль не короче 6 символов</li>
<li>Кнопка «Войти» активна, если оба поля валидны</li>
<li>Цвет рамки поля отражает его состояние, черная — валидно, красная — не валидно</li>
</ol>
<p>Код, описывающий эти ограничения, может выглядеть так:</p>
<p>Обработка любого пользовательского ввода</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>@IBAction</span> <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>textFieldTextDidChange</span>() {
    <span style=color:#75715e>// 1. Зависимость от глобального стейта</span>
    <span style=color:#75715e>// 2. Явное извлечение</span>
    <span style=color:#66d9ef>guard</span>
        <span style=color:#66d9ef>let</span> login = loginView.text,
        <span style=color:#66d9ef>let</span> password = passwordView.text <span style=color:#66d9ef>else</span> {

        <span style=color:#75715e>// 3. Сайд-эффект            </span>
        loginButton.isEnabled = <span style=color:#66d9ef>false</span>
        <span style=color:#66d9ef>return</span>
    }

    <span style=color:#66d9ef>let</span> loginIsValid = login.count <span style=color:#f92672>&gt;</span> constants.loginMinLenght

    <span style=color:#66d9ef>if</span> loginIsValid {
        <span style=color:#75715e>// 4. Сайд-эффект</span>
        loginView.layer.borderColor = constants.normalColor
    }

    <span style=color:#66d9ef>let</span> passwordIsValid = password.count <span style=color:#f92672>&gt;</span> constants.passwordMinLenght

    <span style=color:#66d9ef>if</span> passwordIsValid {
        <span style=color:#75715e>// 5. Сайд-эффект</span>
        passwordView.layer.borderColor = constants.normalColor
    }

    <span style=color:#75715e>// 6. Сайд-эффект</span>
    loginButton.isEnabled = loginIsValid <span style=color:#f92672>&amp;&amp;</span> passwordIsValid
}
</code></pre></div><p>Обработка завершения ввода логина:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>@IBAction</span> <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>loginDidEndEdit</span>() {
    <span style=color:#66d9ef>let</span> color: CGColor
    <span style=color:#75715e>// 1. Зависмость от глобального стейта</span>
    <span style=color:#75715e>// 2. Явное извлечение</span>
    <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> login = loginView.text, login.count <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>3</span> {
        color = constants.normalColor
    } <span style=color:#66d9ef>else</span> {
        color = constants.errorColor
    }
    <span style=color:#75715e>// 3. Сайд эфект</span>
    loginView.layer.borderColor = color
}
</code></pre></div><p>Обработка завершения ввода пароля:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>@IBAction</span> <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>passwordDidEndEdit</span>() {
    <span style=color:#66d9ef>let</span> color: CGColor
    <span style=color:#75715e>// 1. Зависимость от глобального стейта</span>
    <span style=color:#75715e>// 2. Явное извлечение</span>
    <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> password = passwordView.text, password.count <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>6</span> {
        color = constants.normalColor
    } <span style=color:#66d9ef>else</span> {
        color = constants.errorColor
    }
    <span style=color:#75715e>// 3. Сайд-эффект</span>
    passwordView.layer.borderColor = color
}
</code></pre></div><p>Нажатие на кнопку войти:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>@IBAction</span> <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>loginPressed</span>() {
    <span style=color:#75715e>// 1. Зависимость от глобального стейта</span>
    <span style=color:#75715e>// 2. Явное извлечение</span>
    <span style=color:#66d9ef>guard</span>
        <span style=color:#66d9ef>let</span> login = loginView.text,
        <span style=color:#66d9ef>let</span> password = passwordView.text <span style=color:#66d9ef>else</span> {
            <span style=color:#66d9ef>return</span>
    }

    auth(login: login, password: password) { [<span style=color:#66d9ef>weak</span> <span style=color:#66d9ef>self</span>] user, error <span style=color:#66d9ef>in</span>
        <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> user = user {
            <span style=color:#75715e>/* успех */</span>
        } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> error <span style=color:#66d9ef>is</span> AuthError {
            <span style=color:#66d9ef>guard</span> <span style=color:#66d9ef>let</span> `<span style=color:#66d9ef>self</span>` = <span style=color:#66d9ef>self</span> <span style=color:#66d9ef>else</span> { <span style=color:#66d9ef>return</span> }
            <span style=color:#75715e>// 3. Сайд-эффект</span>
            <span style=color:#66d9ef>self</span>.passwordView.layer.borderColor = <span style=color:#66d9ef>self</span>.constants.errorColor
            <span style=color:#75715e>// 4. Сайд-эффект</span>
            <span style=color:#66d9ef>self</span>.loginView.layer.borderColor = <span style=color:#66d9ef>self</span>.constants.errorColor
        } <span style=color:#66d9ef>else</span> {
            <span style=color:#75715e>/* Другие ошибки */</span>
        }
    }
}
</code></pre></div><p>Возможно, этот код не самый лучший, но в целом он неплох и работает. Правда, у него есть ряд проблем:</p>
<ul>
<li>4 явных извлечения;</li>
<li>4 зависимости от глобального стейта;</li>
<li>8 сайд-эффектов;</li>
<li>неочевидные конечные состояния;</li>
<li>нелинейный флоу.</li>
</ul>
<p>Главная проблема состоит в том, что нельзя просто взять и сказать, что происходит с нашим экраном. Глядя на один метод, мы видим, что он делает с глобальным стейтом, но не знаем, кто, где и когда еще трогает стейт. В итоге, чтобы разобраться в происходящем, надо найти все точки работы с вьюшками и понять, в каком порядке какие воздействия происходят. Удержать все это в голове очень сложно.</p>
<p>Если процесс изменения состояния линейный, можно изучать его шаг за шагом, что снизит когнитивную нагрузку на программиста.</p>
<p>Попробуем изменить пример, сделав его более функциональным.</p>
<p>Для начала определим модель, описывающую текущее состояние экрана. Это позволит точно знать, какая информация необходима для работы.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>LoginOutputModel</span> {
    <span style=color:#66d9ef>let</span> login: String
    <span style=color:#66d9ef>let</span> password: String

    <span style=color:#66d9ef>var</span> loginIsValid: Bool {
        <span style=color:#66d9ef>return</span> login.count <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>3</span>
    }

    <span style=color:#66d9ef>var</span> passwordIsValid: Bool {
        <span style=color:#66d9ef>return</span> password.count <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>6</span>
    }

    <span style=color:#66d9ef>var</span> isValid: Bool {
        <span style=color:#66d9ef>return</span> loginIsValid <span style=color:#f92672>&amp;&amp;</span> passwordIsValid
    }
}
</code></pre></div><p>Модель, описывающую изменения, применяемые к экрану. Она нужна, чтобы точно знать, что мы будем менять.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>LoginInputModel</span> {
    <span style=color:#66d9ef>let</span> loginBorderColor: CGColor?
    <span style=color:#66d9ef>let</span> passwordBorderColor: CGColor?
    <span style=color:#66d9ef>let</span> loginButtonEnable: Bool?
    <span style=color:#66d9ef>let</span> popupErrorMessage: String?
}
</code></pre></div><p>События, которые могут привести к новому состоянию экрана. Так мы точно будем знать, какие действия изменяют экран.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>Event</span> {
    <span style=color:#66d9ef>case</span> textFieldTextDidChange
    <span style=color:#66d9ef>case</span> loginDidEndEdit
    <span style=color:#66d9ef>case</span> passwordDidEndEdit
    <span style=color:#66d9ef>case</span> loginPressed
    <span style=color:#66d9ef>case</span> authFailure(Error)
}
</code></pre></div><p>Теперь опишем главный метод изменения. Эта чистая функция на основе события текущего состояния собирает новое состояние экрана.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>makeInputModel</span>(
    event: Event,
    outputModel: LoginOutputModel?) -&gt; LoginInputModel {

    <span style=color:#66d9ef>switch</span> event {
    <span style=color:#66d9ef>case</span> .textFieldTextDidChange:
        <span style=color:#66d9ef>let</span> mapValidToColor: (Bool) -&gt; CGColor? = { $0 ? normalColor : <span style=color:#66d9ef>nil</span> }
    <span style=color:#66d9ef>return</span> LoginInputModel(
            loginBorderColor: outputModel
                .map { $0.loginIsValid }
                .flatMap(mapValidToColor),
            passwordBorderColor: outputModel
                .map { $0.passwordIsValid }
                .flatMap(mapValidToColor),
            loginButtonEnable: outputModel?.passwordIsValid
            )
    <span style=color:#66d9ef>case</span> .loginDidEndEdit:
        <span style=color:#66d9ef>return</span> LoginInputModel(<span style=color:#75715e>/**/</span>)
    <span style=color:#66d9ef>case</span> .passwordDidEndEdit:
        <span style=color:#66d9ef>return</span> LoginInputModel(<span style=color:#75715e>/**/</span>)
    <span style=color:#66d9ef>case</span> .loginPressed:
        <span style=color:#66d9ef>return</span> LoginInputModel(<span style=color:#75715e>/**/</span>)
    <span style=color:#66d9ef>case</span> .authFailure(<span style=color:#66d9ef>let</span> error) <span style=color:#66d9ef>where</span> error <span style=color:#66d9ef>is</span> AuthError:
        <span style=color:#66d9ef>return</span> LoginInputModel(<span style=color:#75715e>/**/</span>)
    <span style=color:#66d9ef>case</span> .authFailure:
        <span style=color:#66d9ef>return</span> LoginInputModel(<span style=color:#75715e>/**/</span>)
    }
}
</code></pre></div><p>Самое важное в том, что этот метод единственный, кому позволено заниматься конструированием нового состояния — и он чистый. Его можно изучить шаг за шагом. Увидеть, как события преобразуют экран из точки А в точку Б. Если что-то сломается, то проблема точно здесь. И это легко тестировать.</p>
<p>Добавим вспомогательное свойство для получения текущего состояния, это единственный метод, зависящий от глобального состояния.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>var</span> outputModel: LoginOutputModel? {
    <span style=color:#66d9ef>return</span> perform(LoginOutputModel.<span style=color:#66d9ef>init</span>, loginView.text, passwordView.text)
}
</code></pre></div><p>Добавим еще один «грязный» метод для создания сайд-эффектов изменения экрана.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>updateView</span>(<span style=color:#66d9ef>_</span> event: Event) {

    <span style=color:#66d9ef>let</span> inputModel = makeInputModel(event: event, outputModel: outputModel)
        <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> color = inputModel.loginBorderColor {
        loginView.layer.borderColor = color
    }
    <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> color = inputModel.passwordBorderColor {
        passwordView.layer.borderColor = color
    }
    <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> isEnable = inputModel.loginButtonEnable {
            loginButton.isEnabled = isEnable
    }
    <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> error = inputModel.popupErrorMessage {
            showPopup(error)
    }
}
</code></pre></div><p>Хотя метод updateView и не является чистым, но это единственное место, где меняются свойства экрана. Первый и последний пункт в цепочке вычислений. И если что-то пошло не так, именно тут будет стоять брейкпоинт.</p>
<p>Осталось только запустить преобразования в нужных местах.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>@IBAction</span> <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>textFieldTextDidChange</span>() {
    updateView(.textFieldTextDidChange)
}

<span style=color:#66d9ef>@IBAction</span> <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>loginDidEndEdit</span>() {
    updateView(.loginDidEndEdit)
}

<span style=color:#66d9ef>@IBAction</span> <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>passwordDidEndEdit</span>() {
    updateView(.passwordDidEndEdit)
}
</code></pre></div><p>Метод loginPressed вышел немного уникальным.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>@IBAction</span> <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>loginPressed</span>() {

    updateView(.loginPressed)

    <span style=color:#66d9ef>let</span> completion: (Result&lt;User, Error&gt;) -&gt; Void = { [<span style=color:#66d9ef>weak</span> <span style=color:#66d9ef>self</span>] result <span style=color:#66d9ef>in</span>
        <span style=color:#66d9ef>switch</span> result {
        <span style=color:#66d9ef>case</span> .success(<span style=color:#66d9ef>let</span> user):
            <span style=color:#75715e>/* успех */</span>                 
        <span style=color:#66d9ef>case</span> .failure(<span style=color:#66d9ef>let</span> error):
            <span style=color:#66d9ef>self</span>?.updateView(.authFailure(error))
        }
    }

    outputModel.map {
        auth(login: $0.login, password: $0.password, completion: completion)
    }

}
</code></pre></div><p>Дело в том, что нажатие на кнопку «Войти» запускает две цепочки вычислений, что не запрещается.</p>
<h2 id=заключение>Заключение<a hidden class=anchor aria-hidden=true href=#заключение>#</a></h2>
<p>До начала изучения ФП я делал сильный акцент на парадигмах программирования. Для меня было важно, чтобы код следовал ООП, я не любил статические функции или объекты без состояний, не писал глобальных функций.</p>
<p>Сейчас мне кажется, что все те вещи, что я считал частью той или иной парадигмы — довольно условны. Главное — это чистый, понятный код. Для достижения этой цели можно использовать все, что возможно: чистые функции, классы, монады, наследование, композиция, вывод типов. Все они хорошо уживаются вместе и делают код лучше — достаточно применять их к месту.</p>
</div>
<footer class=post-footer>
<ul class=post-tags>
<li><a href=https://jonfir.github.io/tags/fp/>FP</a></li>
<li><a href=https://jonfir.github.io/tags/swift/>Swift</a></li>
<li><a href=https://jonfir.github.io/tags/ios/>iOS</a></li>
</ul>
<nav class=paginav>
<a class=prev href=https://jonfir.github.io/posts/ios-materials/>
<span class=title>« Предыдущая</span>
<br>
<span>Полезный контент для iOS разработчика (Обновляется)</span>
</a>
<a class=next href=https://jonfir.github.io/posts/ios-project-structure/>
<span class=title>Следующая »</span>
<br>
<span>Структура iOS проекта</span>
</a>
</nav>
<div class=share-buttons>
<a target=_blank rel="noopener noreferrer" aria-label="share Функциональный Swift — это просто on twitter" href="https://twitter.com/intent/tweet/?text=%d0%a4%d1%83%d0%bd%d0%ba%d1%86%d0%b8%d0%be%d0%bd%d0%b0%d0%bb%d1%8c%d0%bd%d1%8b%d0%b9%20Swift%20%e2%80%94%20%d1%8d%d1%82%d0%be%20%d0%bf%d1%80%d0%be%d1%81%d1%82%d0%be&url=https%3a%2f%2fjonfir.github.io%2fposts%2feasy-fp-swift%2f&hashtags=FP%2cSwift%2ciOS"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Функциональный Swift — это просто on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fjonfir.github.io%2fposts%2feasy-fp-swift%2f&title=%d0%a4%d1%83%d0%bd%d0%ba%d1%86%d0%b8%d0%be%d0%bd%d0%b0%d0%bb%d1%8c%d0%bd%d1%8b%d0%b9%20Swift%20%e2%80%94%20%d1%8d%d1%82%d0%be%20%d0%bf%d1%80%d0%be%d1%81%d1%82%d0%be&summary=%d0%a4%d1%83%d0%bd%d0%ba%d1%86%d0%b8%d0%be%d0%bd%d0%b0%d0%bb%d1%8c%d0%bd%d1%8b%d0%b9%20Swift%20%e2%80%94%20%d1%8d%d1%82%d0%be%20%d0%bf%d1%80%d0%be%d1%81%d1%82%d0%be&source=https%3a%2f%2fjonfir.github.io%2fposts%2feasy-fp-swift%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Функциональный Swift — это просто on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fjonfir.github.io%2fposts%2feasy-fp-swift%2f&title=%d0%a4%d1%83%d0%bd%d0%ba%d1%86%d0%b8%d0%be%d0%bd%d0%b0%d0%bb%d1%8c%d0%bd%d1%8b%d0%b9%20Swift%20%e2%80%94%20%d1%8d%d1%82%d0%be%20%d0%bf%d1%80%d0%be%d1%81%d1%82%d0%be"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Функциональный Swift — это просто on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fjonfir.github.io%2fposts%2feasy-fp-swift%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Функциональный Swift — это просто on whatsapp" href="https://api.whatsapp.com/send?text=%d0%a4%d1%83%d0%bd%d0%ba%d1%86%d0%b8%d0%be%d0%bd%d0%b0%d0%bb%d1%8c%d0%bd%d1%8b%d0%b9%20Swift%20%e2%80%94%20%d1%8d%d1%82%d0%be%20%d0%bf%d1%80%d0%be%d1%81%d1%82%d0%be%20-%20https%3a%2f%2fjonfir.github.io%2fposts%2feasy-fp-swift%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Функциональный Swift — это просто on telegram" href="https://telegram.me/share/url?text=%d0%a4%d1%83%d0%bd%d0%ba%d1%86%d0%b8%d0%be%d0%bd%d0%b0%d0%bb%d1%8c%d0%bd%d1%8b%d0%b9%20Swift%20%e2%80%94%20%d1%8d%d1%82%d0%be%20%d0%bf%d1%80%d0%be%d1%81%d1%82%d0%be&url=https%3a%2f%2fjonfir.github.io%2fposts%2feasy-fp-swift%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg>
</a>
</div>
</footer><div id=disqus_thread></div>
<script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return}var b=document,a=b.createElement('script');a.async=!0,a.src='//jonfir.disqus.com/embed.js',a.setAttribute('data-timestamp',+new Date),(b.head||b.body).appendChild(a)})()</script>
<noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript>
<a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a>
</article>
</main>
<footer class=footer>
<span>&copy; 2022 <a href=https://jonfir.github.io>JonFir</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
<script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerText='копировать';function d(){a.innerText='скопировано!',setTimeout(()=>{a.innerText='копировать'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script>
</body>
</html>