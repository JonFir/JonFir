<!doctype html><html lang=ru dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>Инверсия управления в iOS | JonFir</title>
<meta name=keywords content="DI,Swift,iOS">
<meta name=description content="Полная теория о DI и service locator">
<meta name=author content="Евгений Елчев">
<link rel=canonical href=https://jonfir.github.io/posts/ioc-ios/>
<link crossorigin=anonymous href=/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css integrity="sha256-yIlj/i15RiAA/Q+xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://jonfir.github.io/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://jonfir.github.io/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=https://jonfir.github.io/favicon-32x32.png>
<link rel=apple-touch-icon href=https://jonfir.github.io/apple-touch-icon.png>
<link rel=mask-icon href=https://jonfir.github.io/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.91.2">
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript><meta property="og:title" content="Инверсия управления в iOS">
<meta property="og:description" content="Полная теория о DI и service locator">
<meta property="og:type" content="article">
<meta property="og:url" content="https://jonfir.github.io/posts/ioc-ios/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2018-07-24T15:23:11+07:00">
<meta property="article:modified_time" content="2018-07-24T15:23:11+07:00"><meta property="og:site_name" content="JonFir">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="Инверсия управления в iOS">
<meta name=twitter:description content="Полная теория о DI и service locator">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://jonfir.github.io/posts/"},{"@type":"ListItem","position":3,"name":"Инверсия управления в iOS","item":"https://jonfir.github.io/posts/ioc-ios/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Инверсия управления в iOS","name":"Инверсия управления в iOS","description":"Полная теория о DI и service locator","keywords":["DI","Swift","iOS"],"articleBody":"В последнее время я все чаще слышу о DI. Им интересуются мои студенты в Geek University, его упоминают в чатах. Хотя паттерн далеко не молод, многие не совсем верно его понимают. Часто под DI подразумевают фреймворк, например, typhoon или swinject. В статье подробно разберем принципы реализации DI, а также принцип IoC.\n DI (внедрение зависимости, англ. Dependency injection) — процесс предоставления внешней зависимости программному компоненту. Является специфичной формой «IoC», когда она применяется к управлению зависимостями. В полном соответствии с принципом единственной ответственности объект отдаёт заботу о построении требуемых ему зависимостей внешнему, специально предназначенному для этого общему механизму.\n  IoC (Инверсия управления, англ. Inversion of Control) — важный принцип объектно-ориентированного программирования, используемый для уменьшения зацепления (связанности) в компьютерных программах.\n Несмотря на то, что статья о DI, начнем мы свой путь не с него, а с IoC, по той причине, что DI -это лишь один из видов IoC и картину нужно видеть целиком.\nIoC Для начала разберемся с тем, что такое управление. Возьмем самый простой пример — консольный «Hello world»:\nlet firstWord = \"hello\" let secondWord = \"world!\" let phrase = firstWord + \" \" + secondWord print(phrase) В данном примере наши команды управляют данными, которые представлены строковыми литералами и переменными. На этом уровне абстракции больше нет никакого управления, но мы можем его добавить с помощью тернарного оператора:\nlet number = arc4random_uniform(1) let firstWord = number == 0 ? \"hello\" : \"bye\" let secondWord = \"world!\" let phrase = firstWord + \" \" + secondWord print(phrase) Наш код стал неоднозначен, и теперь, в зависимости от случайного числа, строка в консоле изменится. Другими словами, данные управляют нашей программой. Это самый банальный и простой пример инверсии управления.\nВ типичном iOS-приложении управление находится повсюду. Система, пользователь, сервер управляют приложением. Приложение управляет сервером, пользователем и системой. Наш код содержит огромное количество объектов, которые тоже управляют друг другом. Например, объект класса AuthViewController может управлять объектом класса AuthService.\nТакое управление объектами в свою очередь строится из нескольких аспектов. Во-первых, AuthViewController вызывает методы AuthService, во-вторых, он его создает. Все это приводит к высокой связанности объектов, использование AuthViewController становится невозможным без AuthService. Это называется зависимостью, AuthViewController полностью зависим от AuthService.\nЕсть мнение, что ничего страшного в таких зависимостях нет. Как правило, наши контроллеры не переиспользуются и идут рука об руку вместе со своими сервисами все время поддержки приложения. Но те, кто занимался поддержкой долгоживущих приложений, знает, что это не так. Требования постоянно меняются, мы находим баги, меняем flow, делаем редизайн. Если при этом ваше приложение сложнее чем несколько контроллеров с парой кнопок и сервисов, которые просто обертки для URLSession, то оно тонет в зависимостях. Зависимости между классами образуют паутину, иногда можно обнаружить циклические зависимости. Вы не можете вносить изменения в ваши классы, потому что не ясно, как и где они используются, вам проще создать новый метод, чем изменить старый. Замена класса и вовсе превращается в боль. Вызов его конструктора раскидан по различным методам, которые вы тоже вынуждены изменять. В конце концов, вы перестаете понимать, что происходит, код превращается в обычный текст и, вооружившись поиском, вы начинаете заменять слова или предложения в этом тексте, проверяя только ошибки компилятора.\nЧтобы не допустить такого исхода событий, придумано множество принципов и техник. Например, один из принципов SOLID принцип DIP описывает, как уменьшить связанность при вызове методов и это является IoC.\n DIP (принцип инверсии зависимостей, англ. dependency inversion principle) — один пяти из принципов SOLID.\nФормулировка:\nМодули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей должны зависеть от абстракций.\nАбстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.\n Но все же, когда кто-то говорит «IoC», он имеет ввиду инверсию управления при создании зависимостей. Далее я буду использовать его только в этом значении. Кстати, DIP практически невозможно реализовать без IoC, но не наоборот. Использование IoC не гарантирует соблюдение DIP. Еще один важный нюанс. DIP и DI — это разные принципы.\nНа пути к IoC На самом деле, IoC — это очень простая концепция, и не нужно читать много литературы, уходить на несколько лет в Тибет, чтобы постичь дзен и начать ее использовать.\nВ качестве примера я буду рассматривать класс «рыцаря» (Knight) и его «доспехов» (Armor), все классы показаны ниже.\nТеперь посмотрим на реализацию класса Armor\nclass Armor { private var boots: Boots? private var pants: Pants? private var belt: Belt? private var chest: Chest? private var bracers: Bracers? private var gloves: Gloves? private var helmet: Helmet? func configure() { self.boots = Boots() self.pants = Pants() self.belt = Belt() self.chest = Chest() self.bracers = Bracers() self.gloves = Gloves() self.helmet = Helmet() } } и Knight\nclass Knight { private var armor: Armor? func prepareForBattle() { self.armor = Armor() self.armor.configure() } } На первый взгляд — все хорошо. Если нам понадобится рыцарь, мы просто его создадим.\nlet knight = Knight() Но не все так просто. К сожалению, суррогатные примеры не могут передать всю боль, которую несет такой подход.\nНаши классы спаяны вместе. В методе make у Armor создается 7 классов. Это делает классы закостенелыми. При таком подходе мы не можем просто определить, где и как создается класс. Если потребуется отнаследоваться от брони и создать, например, парадную броню, заменив шлем, нам придется переопределять весь метод.\nЕдинственный плюс в таком подходе — это скорость написания кода, ведь при создании классов не приходится думать о будущем.\nВот небольшой пример, как это может выглядеть в жизни:\nclass FightViewController: BaseViewController { var titleLabel: UIView! var knightList: UIView! override func viewDidLoad() { super.viewDidLoad() self.title = \"Турнир\" // Далее в коде смешаны не связанные действия, что затрудняет изменение их по отдельности // Создание зависимости let backgroundView = UIView() // Добавление на экран self.view.addSubview(backgroundView) // Настройка внешнего вида backgroundView.backgroundColor = UIColor.red // Настройка позиционирования backgroundView.translatesAutoresizingMaskIntoConstraints = false backgroundView.translatesAutoresizingMaskIntoConstraints = false backgroundView.leadingAnchor.constraint(equalTo: leadingAnchor).isActive = true backgroundView.topAnchor.constraint(equalTo: topAnchor).isActive = true backgroundView.trailingAnchor.constraint(equalTo: trailingAnchor).isActive = true backgroundView.bottomAnchor.constraint(equalTo: bottomAnchor).isActive = true let title = Views.BigHeader.View() self.titleLabel = title title.labelView.text = \"labelView\" self.view.addSubview(title) title.translatesAutoresizingMaskIntoConstraints = false title.leadingAnchor.constraint(equalTo: leadingAnchor).isActive = true title.topAnchor.constraint(equalTo: topAnchor).isActive = true title.trailingAnchor.constraint(equalTo: trailingAnchor).isActive = true title.heightAnchor.constraint(equalToConstant: 56).isActive = true let knightList = Views.DataView.View() self.knightList = knightList knightList.titleView.text = \"knightList\" knightList.dataView.text = \"\" self.view.addSubview(knightList) knightList.translatesAutoresizingMaskIntoConstraints = false knightList.leadingAnchor.constraint(equalTo: leadingAnchor).isActive = true knightList.topAnchor.constraint(equalTo: title.topAnchor).isActive = true knightList.trailingAnchor.constraint(equalTo: trailingAnchor).isActive = true knightList.heightAnchor.constraint(equalToConstant: 45).isActive = true } } Такой код легко встретить в чьем-нибудь проекте. Он прекрасно иллюстрирует, что создание классов зависимостей в произвольных местах — не очень хорошая идея. К тому же, в отличии от брони, элементы здесь не только создаются, но настраиваются и даже позиционируются. Код превратился в кашу.\nКак это можно улучшить? Воспользоваться паттерном «фабричный метод». Он не решит всех проблем, но сделает класс более гибким.\n Фабричный метод (англ. Factory Method, также известен как Виртуальный конструктор (англ. Virtual Constructor)) — порождающий шаблон проектирования, предоставляющий подклассам интерфейс для создания экземпляров некоторого класса.\n class Armor { private var boots: Boots? private var pants: Pants? func configure() { self.boots = makeBoots() self.pants = makePants() } func makeBoots() - Boots { return Boots() } func makePants() - Pants { return Pants() } } Уже лучше, создание зависимостей вынесено в отдельные методы. Их просто найти, просто изменить без риска повредить логику класса. При наследовании мы можем их переопределять и тем самым переопределять зависимости.\nНо все же, нашему классу не стоит знать о подробностях создания своих зависимостей, он должен просто использовать их. Как с этим бороться? Необходимо выносить порождающую логику из класса на уровень выше.\n Порождающая логика — код, создающий экземпляры класса или структуры. Другими словами — код, порождающий объекты.\n class Armor { private var boots: Boots? private var pants: Pants? func configure(boots: Boots?, pants: Pants?) { self.boots = boots self.pants = pants } } Теперь наш класс Armor понятия не имеет как создаются его зависимости, они просто передаются в качестве аргументов. Это дает максимальную гибкость. Мы даже можем заменить классы на протоколы и полностью абстрагироваться от деталей реализации.\nНо вот у нашего класса Knight дела идут не так хорошо.\nclass Knight { private var armor: Armor? func preapreForBattle() { self.armor = Armor() let boots = makeBoots() let pants = makePants() self.armor?.make(boots: boots, pants: pants) } func makeBoots() - Boots { return Boots() } func makePants() - Pants { return Pants() } } Он создает все части своей брони. Можно сказать, наш рыцарь сам себе кузнец. Это неправильно, рыцари не должны ковать себе броню, не их уровня задача, но как тогда быть? Можно вновь вынести порождающую логику на уровень выше, но тогда класс на вершине графа будет огромной свалкой по созданию зависимостей.\nНа помощь нам придет другой порождающий паттерн — «фабрика».\n Фабрика (англ. Factory) — объект, создающий другие объекты.\n Мы построим кузницу, в которой будут изготавливаться части брони и собираться в единый комплект.\nclass Forge { func makeArmor() - Armor { let armor = Armor() armor.boots = makeBoots() armor.pants = makePants() return armor } func makeBoots() - Boots { return Boots() } func makePants() - Pants { return Pants() } } Классы Armor и Knight избавятся от порождающей логики и будут смотреться лаконично.\nclass Armor { var boots: Boots? var pants: Pants? } class Knight { var armor: Armor? } Теперь перед нами встает вопрос: как, где и когда забрать зависимости из «фабрики» и передать нашим классам. А, значит, мы наконец пришли к понятиям DI и SL.\nСервис локатор (SL) Начнем, пожалуй, с этого паттерна. Во-первых, он проще. Во-вторых, многие думают, что это и есть DI, хотя это не так.\n SL (сервис локатор, англ. service locator) — это шаблон проектирования, используемый в разработке программного обеспечения для инкапсуляции процессов, связанных с получением какого-либо сервиса с сильным уровнем абстракции. Этот шаблон использует центральный реестр, известный как «локатор сервисов», который по запросу возвращает информацию (как правило, это объекты), необходимую для выполнения определенной задачи.\n В чем же его суть? Классу для того, чтобы получить зависимости, в конструкторе передается «фабрика», из которой он сам выбирает, что же ему получить.\nВ этом случае наши классы будут выглядеть так:\nclass Forge { func makeArmor() - Armor { let armor = Armor(forge: self) return armor } func makeBoots() - Boots { return Boots() } func makePants() - Pants { return Pants() } } class Knight { private let forge: Forge private var armor: Armor? init(forge: Forge) { self.forge = forge configure() } private func configure() { armor = forge.makeArmor() } } class Armor { private let forge: Forge private var boots: Boots? private var pants: Pants? init(forge: Forge) { self.forge = forge configure() } private func configure() { boots = forge.makeBoots() pants = forge.makePants() } } let forge = Forge() let knight = Knight(forge: forge) Лично у меня такой подход вызывает двоякое чувство. С одной стороны, порождающая логика находится в «фабрике», с другой стороны, процесс получения зависимостей несколько запутан. Но самый главный недостаток состоит в том, что, глядя на класс, нельзя однозначно определить его зависимости. Он может получить из «фабрики» все что угодно, типичной ошибкой разработки является создание одной такой «фабрики» на все приложение. При этом «фабрика» превращается в огромную свалку барахла и порождает искушение доставать внутри классов то, что им на самом деле не нужно. У классов пропадает контакт, ограничения.\nМожно представить, что нашему рыцарю подарили сундук с сокровищами, из которого он может достать необходимую ему броню, но в довесок никто не помешает ему набрать ненужных украшений. Именно по этой причине этот паттерн пересек черту добра и зла и превратился в антипаттерн. Если у вас есть выбор между DI и SL, всегда выбирайте DI.\nDI Вторым способом доставки зависимостей к классам является DI. В настоящее время это наиболее распространенный паттерн. Он настолько популярен, что в мире бэкенда все нормальные фреймворки поддерживают его из коробки. Нам, к сожалению, так не повезло.\nСуть этого паттерна заключается в том, что зависимости внедряются в класс извне, при этом граф зависимостей строится внутри DI контейнера, который является «фабрикой» или набором «фабрик».\nНаши классы при этом выглядят так:\nclass Armor { var boots: Boots? var pants: Pants? } class Knight { var armor: Armor? } class Forge { func makeArmor() - Armor { let armor = Armor() armor.boots = makeBoots() armor.pants = makePants() return armor } func makeBoots() - Boots { return Boots() } func makePants() - Pants { return Pants() } } class Garrison { lazy var forge: Forge = { return Forge() }() func makeKnight() - Knight { let knight = Knight() knight.armor = forge.makeArmor() return knight } } let garrison = Garrison() let knight = garrison.makeKnight() В данном случае классы выглядят чистыми, в них полностью отсутствует порождающая логика. Всю ответственность по сборке на себя взяли две «фабрики»: Garrison и Forge. При желании количество этих «фабрик» можно увеличивать, чтобы не допускать разрастания классов. Хорошей практикой является создание «фабрики», ответственной за создание каких-либо родственных объектов. Например, эта «фабрика» может создать сервисы, контроллеры для конкретной user story.\nПри этом наш рыцарь наконец закончил заниматься не подобающими его статусу вещами, за его амуницию отвечает оруженосец, а рыцарь может сосредоточиться на поединках и принцессах. На этом можно было бы закончить, но стоит поговорить о некоторых аспектах DI и доступных на данный момент фреймворках.\nТипы DI Initializer Injection — внедрение зависимостей через конструктор. Этот подход используется в случае, когда класс не может существовать без своих зависимостей, но даже если это не так, то его можно использовать для более явного определения контракта класса. Если все зависимости объявлены в качестве аргументов конструктора, определить их проще простого. Но не стоит увлекаться, если у класса десяток зависимостей, то лучше не передавать их в конструкторе (а еще лучше разобраться, зачем вашему классу столько зависимостей).\nclass Armor { let boots: Boots let pants: Pants init(boots: Boots, pants: Pants) { self.boots = boots self.pants = pants } } class Forge { func makeArmor() - Armor { let boots = makeBoots() let pants = makePants() let armor = Armor(boots: boots, pants: pants) return armor } func makeBoots() - Boots { return Boots() } func makePants() - Pants { return Pants() } } Property Injection — внедрение зависимостей через свойства. Этот способ используется, когда у класса имеются необязательные зависимости, без которых он может обойтись, или когда зависимости могут изменяться не только на этапе инициализации объекта.\nclass Armor { var boots: Boots? var pants: Pants? } class Forge { func makeArmor() - Armor { let armor = Armor() armor.boots = makeBoots() armor.pants = makePants() return armor } func makeBoots() - Boots { return Boots() } func makePants() - Pants { return Pants() } } Method Injection — внедрение зависимостей через метод. Этот способ очень похож на Property Injection, но с его помощью можно внедрить временную зависимость только на момент выполнения какого-либо действия или более тесно связать внедрение зависимости с логикой класса.\nclass Knight { private var armor: Armor? func winTournament(armor: Armor) { self.armor = armor defeatEnemy() seducePrincess() self.armor = nil } func defeatEnemy() {} func seducePrincess() {} } class Garrison { lazy var forge: Forge = { return Forge() }() func makeKnight() - Knight { let knight = Knight() return knight } } let garrison = Garrison() let knight = garrison.makeKnight() let armor = garrison.forge.makeArmor() knight.winTournament(armor: armor) По моим наблюдениям наиболее распространенными типами являются Initializer Injection и Property Injection, реже используется Method Injection. И хотя я описал типичные случаи выбора того или иного типа, надо помнить, что Swift является очень гибким языком, предоставляя больше возможностей для выбора типа. Так, например, даже имея необязательные зависимости, можно реализовать конструктор с опциональными аргументами и nil по умолчанию. В таком случае можно использовать Initializer Injection вместо Property Injection. В любом случае это компромисс, который может улучшить или ухудшить ваш код, и выбор остается за вами.\nDIP Простое использование IoC, как в примерах выше, само по себе приносит неплохие дивиденды, но можно пойти дальше и добиться соблюдения принципа DIP из SOLID. Для этого мы закроем зависимости протоколами, и только «фабрики» будут знать, какая же конкретно кроется реализация за этим протоколом.\nclass Knight { var armor: AbstractArmor? } class Forge { func makeArmor() - AbstractArmor { let armor = Armor() armor.boots = makeBoots() armor.pants = makePants() return armor } func makeBoots() - Boots { return Boots() } func makePants() - Pants { return Pants() } } В этом случае мы можем без проблем подменять реализацию брони на альтернативную.\nSOLID лежит за пределами данной статьи, тем не менее, если вы не знаете, что это такое лучше ознакомиться с этим набором принципов. Можно начать с неплохой вводной статьи, продолжить чтением соответствующих глав в этой книге.\nОбласти видимости Само по себе управление областью видимости объектов не является частью IoC концепции, это скорее детали ее реализации, но тем не менее это очень мощный механизм, который позволяет отказаться от синглтонов и решить другие проблемы с общими зависимостями. Область видимости определяет, как долго будет жить зависимость, созданная внутри «фабрики», будет ли оно создаваться каждый раз заново или сохраняться после первого создания и просто передаваться по ссылке.\nТак как области видимости не описаны в паттернах, каждый реализует и именует их как считает нужным. Мы рассмотрим два наиболее часто используемых типа.\nСтандартная область видимости — это то поведение, какое мы реализовали во всех примерах выше. «Фабрика» создает объект, отдает его и забывает о его существовании. При повторном вызове фабричного метода будет создан новый объект.\nОбласть видимости контейнера — это поведение схожее с синглтоном. При первом вызове фабричного метода создается новый объект, затем «фабрика» сохраняет ссылку на него и возвращает как результат работы фабричного метода, при всех остальных вызовах метода новый объект не создается, а возвращается ссылка на первый объект.\nclass Forge { private var armor: AbstractArmor? func makeArmor() - AbstractArmor { // Если броня уже создана ранее вернеем ее if let armor = self.armor { return armor } let armor = Armor() armor.boots = makeBoots() armor.pants = makePants() self.armor = armor return armor } func makeBoots() - Boots { return Boots() } func makePants() - Pants { return Pants() } } Как вы видите, в примере выше броня создается только один раз, во всех остальных случаях возвращается ранее созданный экземпляр. Аналогично синглтону, мы всегда будем работать с одним и тем же экземпляром класса, при этом без глобальной области видимости.\nПлюсы и минусы Как и любые другие принципы в программировании IoC не является серебряной пулей, у него есть свои плюсы:\n Уменьшает связанность классов; Проще переиспользовать классы; Более компактные классы за счет выноса поражающей логики; Инкапсулирует порождающую логику, что делает ее рефакторинг проще; Скрывает реализацию; Упрощает замену реализации; Упрощает тестирование: подменив “фабрики”, можно заменить зависимости моками; Позволяет шарить объекты в приложении без использования синглтона.  И минусы:\n Увеличивает количество классов при сокрытии реализации за абстракцией; Увеличивает время погружения в проект; Легко может привести к оверинжинирингу.  Хотя мое мнение что, главный и единственный минус — это оверинжиниринг в результате безудержного желания четко следовать принципу DIP. Часто можно увидеть, как создается пачка классов, закрывается вдвое более пухлой пачкой протоколов, и это добро проксирует вызов одного метода.\nЕсли вы подумаете, что хорошо бы создать протокол, сначала подумайте зачем. У вас есть взаимозаменяемые классы, которые необходимо спрятать за общим интерфейсом? Вам требуется сокрыть реализацию, а нельзя обойтись просто модификатором доступа? Для тестирования? Может, для мока хватит простого наследования?\nПодводя итог На мой взгляд, соблюдение принципов IoC является обязательным условием при разработке проекта, который будет поддерживаться, а не просто забыт после релиза. Если мы заглянем за пределы iOS-песочницы, то обнаружим, что в android-разработке использование DI, воплотившегося в виде фреймворка dagger, стало почти стандартом. В мире бэкенда, например, в spring управление зависимостями лежит в основе всей архитектуры фреймворка. Даже php-фреймворки, такие как, например, Laravel призывают использовать DI и предоставляют необходимые инструменты из коробки. В iOS, к сожалению, так и не появилось ни коробочного решения, ни фреймворка, который бы стал стандартом. Да для Objective-C можно считать таковым тайфун, но не для swift.\nК счастью, вам необязательно использовать именитый фреймворк. Одной из целей этой статьи как раз было показать, что IoC — это не фрейворк, и то, что если в проекте нет тайфуна, это не значит, что там нет DI. Для реализации IoC в проекте неважно, выберете вы DI или SL, достаточно обычной «фабрики», которую вполне можно написать самому. Такая «фабрика» является самым простым DI контейнером.\n","wordCount":"3243","inLanguage":"ru","datePublished":"2018-07-24T15:23:11+07:00","dateModified":"2018-07-24T15:23:11+07:00","author":{"@type":"Person","name":"Евгений Елчев"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://jonfir.github.io/posts/ioc-ios/"},"publisher":{"@type":"Organization","name":"JonFir","logo":{"@type":"ImageObject","url":"https://jonfir.github.io/favicon.ico"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://jonfir.github.io accesskey=h title="JonFir (Alt + H)">JonFir</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu>
<li>
<a href=https://jonfir.github.io/archives/ title=Архив>
<span>Архив</span>
</a>
</li>
<li>
<a href=https://jonfir.github.io/tags/ title=Теги>
<span>Теги</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<div class=breadcrumbs><a href=https://jonfir.github.io>Главная</a>&nbsp;»&nbsp;<a href=https://jonfir.github.io/posts/>Posts</a></div>
<h1 class=post-title>
Инверсия управления в iOS
</h1>
<div class=post-description>
Полная теория о DI и service locator
</div>
<div class=post-meta><span title="2018-07-24 15:23:11 +0700 +07">июля 24, 2018</span>&nbsp;·&nbsp;16 мин&nbsp;·&nbsp;Евгений Елчев
</div>
</header> <div class=toc>
<details open>
<summary accesskey=c title="(Alt + C)">
<span class=details>Оглавление</span>
</summary>
<div class=inner><ul>
<li>
<a href=#ioc aria-label=IoC>IoC</a></li>
<li>
<a href=#%d0%bd%d0%b0-%d0%bf%d1%83%d1%82%d0%b8-%d0%ba-ioc aria-label="На пути к IoC">На пути к IoC</a></li>
<li>
<a href=#%d1%81%d0%b5%d1%80%d0%b2%d0%b8%d1%81-%d0%bb%d0%be%d0%ba%d0%b0%d1%82%d0%be%d1%80-sl aria-label="Сервис локатор (SL)">Сервис локатор (SL)</a></li>
<li>
<a href=#di aria-label=DI>DI</a></li>
<li>
<a href=#%d1%82%d0%b8%d0%bf%d1%8b-di aria-label="Типы DI">Типы DI</a></li>
<li>
<a href=#dip aria-label=DIP>DIP</a></li>
<li>
<a href=#%d0%be%d0%b1%d0%bb%d0%b0%d1%81%d1%82%d0%b8-%d0%b2%d0%b8%d0%b4%d0%b8%d0%bc%d0%be%d1%81%d1%82%d0%b8 aria-label="Области видимости">Области видимости</a></li>
<li>
<a href=#%d0%bf%d0%bb%d1%8e%d1%81%d1%8b-%d0%b8-%d0%bc%d0%b8%d0%bd%d1%83%d1%81%d1%8b aria-label="Плюсы и минусы">Плюсы и минусы</a></li>
<li>
<a href=#%d0%bf%d0%be%d0%b4%d0%b2%d0%be%d0%b4%d1%8f-%d0%b8%d1%82%d0%be%d0%b3 aria-label="Подводя итог">Подводя итог</a>
</li>
</ul>
</div>
</details>
</div>
<div class=post-content><p>В последнее время я все чаще слышу о DI. Им интересуются мои студенты в Geek University, его упоминают в чатах. Хотя паттерн далеко не молод, многие не совсем верно его понимают.
Часто под DI подразумевают фреймворк, например, typhoon или swinject. В статье подробно разберем принципы реализации DI, а также принцип IoC.</p>
<blockquote>
<p>DI (внедрение зависимости, англ. Dependency injection) — процесс предоставления внешней зависимости программному компоненту. Является специфичной формой «IoC», когда она применяется к управлению зависимостями. В полном соответствии с принципом единственной ответственности объект отдаёт заботу о построении требуемых ему зависимостей внешнему, специально предназначенному для этого общему механизму.</p>
</blockquote>
<blockquote>
<p>IoC (Инверсия управления, англ. Inversion of Control) — важный принцип объектно-ориентированного программирования, используемый для уменьшения зацепления (связанности) в компьютерных программах.</p>
</blockquote>
<p>Несмотря на то, что статья о DI, начнем мы свой путь не с него, а с IoC, по той причине, что DI -это лишь один из видов IoC и картину нужно видеть целиком.</p>
<h2 id=ioc>IoC<a hidden class=anchor aria-hidden=true href=#ioc>#</a></h2>
<p>Для начала разберемся с тем, что такое управление. Возьмем самый простой пример — консольный «Hello world»:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>let</span> firstWord = <span style=color:#e6db74>&#34;hello&#34;</span>
<span style=color:#66d9ef>let</span> secondWord = <span style=color:#e6db74>&#34;world!&#34;</span>
<span style=color:#66d9ef>let</span> phrase = firstWord <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; &#34;</span> <span style=color:#f92672>+</span> secondWord
print(phrase)
</code></pre></div><p>В данном примере наши команды управляют данными, которые представлены строковыми литералами и переменными. На этом уровне абстракции больше нет никакого управления, но мы можем его добавить с помощью тернарного оператора:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>let</span> number = arc4random_uniform(<span style=color:#ae81ff>1</span>)
<span style=color:#66d9ef>let</span> firstWord = number == <span style=color:#ae81ff>0</span> ? <span style=color:#e6db74>&#34;hello&#34;</span> : <span style=color:#e6db74>&#34;bye&#34;</span>
<span style=color:#66d9ef>let</span> secondWord = <span style=color:#e6db74>&#34;world!&#34;</span>
<span style=color:#66d9ef>let</span> phrase = firstWord <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; &#34;</span> <span style=color:#f92672>+</span> secondWord
print(phrase)
</code></pre></div><p>Наш код стал неоднозначен, и теперь, в зависимости от случайного числа, строка в консоле изменится. Другими словами, данные управляют нашей программой. Это самый банальный и простой пример инверсии управления.</p>
<p>В типичном iOS-приложении управление находится повсюду. Система, пользователь, сервер управляют приложением. Приложение управляет сервером, пользователем и системой. Наш код содержит огромное количество объектов, которые тоже управляют друг другом. Например, объект класса <strong>AuthViewController</strong> может управлять объектом класса <strong>AuthService</strong>.</p>
<p>Такое управление объектами в свою очередь строится из нескольких аспектов. Во-первых, <strong>AuthViewController</strong> вызывает методы <strong>AuthService</strong>, во-вторых, он его создает. Все это приводит к высокой связанности объектов, использование <strong>AuthViewController</strong> становится невозможным без <strong>AuthService</strong>. Это называется зависимостью, <strong>AuthViewController</strong> полностью зависим от <strong>AuthService</strong>.</p>
<p>Есть мнение, что ничего страшного в таких зависимостях нет. Как правило, наши контроллеры не переиспользуются и идут рука об руку вместе со своими сервисами все время поддержки приложения. Но те, кто занимался поддержкой долгоживущих приложений, знает, что это не так. Требования постоянно меняются, мы находим баги, меняем flow, делаем редизайн. Если при этом ваше приложение сложнее чем несколько контроллеров с парой кнопок и сервисов, которые просто обертки для URLSession, то оно тонет в зависимостях. Зависимости между классами образуют паутину, иногда можно обнаружить циклические зависимости. Вы не можете вносить изменения в ваши классы, потому что не ясно, как и где они используются, вам проще создать новый метод, чем изменить старый. Замена класса и вовсе превращается в боль. Вызов его конструктора раскидан по различным методам, которые вы тоже вынуждены изменять. В конце концов, вы перестаете понимать, что происходит, код превращается в обычный текст и, вооружившись поиском, вы начинаете заменять слова или предложения в этом тексте, проверяя только ошибки компилятора.</p>
<p>Чтобы не допустить такого исхода событий, придумано множество принципов и техник. Например, один из принципов SOLID принцип DIP описывает, как уменьшить связанность при вызове методов и это является IoC.</p>
<blockquote>
<p>DIP (принцип инверсии зависимостей, англ. dependency inversion principle) — один пяти из принципов SOLID.</p>
<p>Формулировка:</p>
<p>Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей должны зависеть от абстракций.</p>
<p>Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.</p>
</blockquote>
<p>Но все же, когда кто-то говорит «<strong>IoC</strong>», он имеет ввиду инверсию управления при создании зависимостей. Далее я буду использовать его только в этом значении. Кстати, DIP практически невозможно реализовать без <strong>IoC</strong>, но не наоборот. Использование <strong>IoC</strong> не гарантирует соблюдение DIP. Еще один важный нюанс. DIP и DI — это разные принципы.</p>
<h2 id=на-пути-к-ioc>На пути к IoC<a hidden class=anchor aria-hidden=true href=#на-пути-к-ioc>#</a></h2>
<p>На самом деле, IoC — это очень простая концепция, и не нужно читать много литературы, уходить на несколько лет в Тибет, чтобы постичь дзен и начать ее использовать.</p>
<p>В качестве примера я буду рассматривать класс «рыцаря» (<strong>Knight</strong>) и его «доспехов» (<strong>Armor</strong>), все классы показаны ниже.</p>
<p><img loading=lazy src=/ioc-ios-1.png alt="class scheme">
</p>
<p>Теперь посмотрим на реализацию класса <strong>Armor</strong></p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Armor</span> {
    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>var</span> boots: Boots?
    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>var</span> pants: Pants?
    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>var</span> belt: Belt?
    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>var</span> chest: Chest?
    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>var</span> bracers: Bracers?
    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>var</span> gloves: Gloves?
    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>var</span> helmet: Helmet?

    <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>configure</span>() {
        <span style=color:#66d9ef>self</span>.boots = Boots()
        <span style=color:#66d9ef>self</span>.pants = Pants()
        <span style=color:#66d9ef>self</span>.belt = Belt()
        <span style=color:#66d9ef>self</span>.chest = Chest()
        <span style=color:#66d9ef>self</span>.bracers = Bracers()
        <span style=color:#66d9ef>self</span>.gloves = Gloves()
        <span style=color:#66d9ef>self</span>.helmet = Helmet()
    }

}
</code></pre></div><p>и <strong>Knight</strong></p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Knight</span> {

    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>var</span> armor: Armor?

    <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>prepareForBattle</span>() {
        <span style=color:#66d9ef>self</span>.armor = Armor()
        <span style=color:#66d9ef>self</span>.armor.configure()
    }

}
</code></pre></div><p>На первый взгляд — все хорошо. Если нам понадобится рыцарь, мы просто его создадим.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>let</span> knight = Knight()
</code></pre></div><p>Но не все так просто. К сожалению, суррогатные примеры не могут передать всю боль, которую несет такой подход.</p>
<p>Наши классы спаяны вместе. В методе make у Armor создается 7 классов. Это делает классы закостенелыми. При таком подходе мы не можем просто определить, где и как создается класс. Если потребуется отнаследоваться от брони и создать, например, парадную броню, заменив шлем, нам придется переопределять весь метод.</p>
<p>Единственный плюс в таком подходе — это скорость написания кода, ведь при создании классов не приходится думать о будущем.</p>
<p>Вот небольшой пример, как это может выглядеть в жизни:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>FightViewController</span>: BaseViewController {

    <span style=color:#66d9ef>var</span> titleLabel: UIView!
    <span style=color:#66d9ef>var</span> knightList: UIView!

    <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>viewDidLoad</span>() {
        <span style=color:#66d9ef>super</span>.viewDidLoad()

        <span style=color:#66d9ef>self</span>.title = <span style=color:#e6db74>&#34;Турнир&#34;</span>
        <span style=color:#75715e>// Далее в коде смешаны не связанные действия, что затрудняет изменение их по отдельности</span>
        <span style=color:#75715e>// Создание зависимости</span>
        <span style=color:#66d9ef>let</span> backgroundView = UIView()
        <span style=color:#75715e>// Добавление на экран</span>
        <span style=color:#66d9ef>self</span>.view.addSubview(backgroundView)
        <span style=color:#75715e>// Настройка внешнего вида</span>
        backgroundView.backgroundColor = UIColor.red
        <span style=color:#75715e>// Настройка позиционирования</span>
        backgroundView.translatesAutoresizingMaskIntoConstraints = <span style=color:#66d9ef>false</span>
        backgroundView.translatesAutoresizingMaskIntoConstraints = <span style=color:#66d9ef>false</span>
        backgroundView.leadingAnchor.constraint(equalTo: leadingAnchor).isActive = <span style=color:#66d9ef>true</span>
        backgroundView.topAnchor.constraint(equalTo: topAnchor).isActive = <span style=color:#66d9ef>true</span>
        backgroundView.trailingAnchor.constraint(equalTo: trailingAnchor).isActive = <span style=color:#66d9ef>true</span>
        backgroundView.bottomAnchor.constraint(equalTo: bottomAnchor).isActive = <span style=color:#66d9ef>true</span>

        <span style=color:#66d9ef>let</span> title = Views.BigHeader.View()
        <span style=color:#66d9ef>self</span>.titleLabel = title
        title.labelView.text = <span style=color:#e6db74>&#34;labelView&#34;</span>
        <span style=color:#66d9ef>self</span>.view.addSubview(title)
        title.translatesAutoresizingMaskIntoConstraints = <span style=color:#66d9ef>false</span>
        title.leadingAnchor.constraint(equalTo: leadingAnchor).isActive = <span style=color:#66d9ef>true</span>
        title.topAnchor.constraint(equalTo: topAnchor).isActive = <span style=color:#66d9ef>true</span>
        title.trailingAnchor.constraint(equalTo: trailingAnchor).isActive = <span style=color:#66d9ef>true</span>
        title.heightAnchor.constraint(equalToConstant: <span style=color:#ae81ff>56</span>).isActive = <span style=color:#66d9ef>true</span>

        <span style=color:#66d9ef>let</span> knightList = Views.DataView.View()
        <span style=color:#66d9ef>self</span>.knightList = knightList
        knightList.titleView.text = <span style=color:#e6db74>&#34;knightList&#34;</span>
        knightList.dataView.text = <span style=color:#e6db74>&#34;&#34;</span>

        <span style=color:#66d9ef>self</span>.view.addSubview(knightList)
        knightList.translatesAutoresizingMaskIntoConstraints = <span style=color:#66d9ef>false</span>
        knightList.leadingAnchor.constraint(equalTo: leadingAnchor).isActive = <span style=color:#66d9ef>true</span>
        knightList.topAnchor.constraint(equalTo: title.topAnchor).isActive = <span style=color:#66d9ef>true</span>
        knightList.trailingAnchor.constraint(equalTo: trailingAnchor).isActive = <span style=color:#66d9ef>true</span>
        knightList.heightAnchor.constraint(equalToConstant: <span style=color:#ae81ff>45</span>).isActive = <span style=color:#66d9ef>true</span>
    }

}
</code></pre></div><p>Такой код легко встретить в чьем-нибудь проекте. Он прекрасно иллюстрирует, что создание классов зависимостей в произвольных местах — не очень хорошая идея. К тому же, в отличии от брони, элементы здесь не только создаются, но настраиваются и даже позиционируются. Код превратился в кашу.</p>
<p>Как это можно улучшить? Воспользоваться паттерном «фабричный метод». Он не решит всех проблем, но сделает класс более гибким.</p>
<blockquote>
<p>Фабричный метод (англ. Factory Method, также известен как Виртуальный конструктор (англ. Virtual Constructor)) — порождающий шаблон проектирования, предоставляющий подклассам интерфейс для создания экземпляров некоторого класса.</p>
</blockquote>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Armor</span> {
    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>var</span> boots: Boots?
    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>var</span> pants: Pants?

    <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>configure</span>() {
        <span style=color:#66d9ef>self</span>.boots = makeBoots()
        <span style=color:#66d9ef>self</span>.pants = makePants()
    }

    <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>makeBoots</span>() -&gt; Boots {
        <span style=color:#66d9ef>return</span> Boots()
    }

    <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>makePants</span>() -&gt; Pants {
        <span style=color:#66d9ef>return</span> Pants()
    }
}
</code></pre></div><p>Уже лучше, создание зависимостей вынесено в отдельные методы. Их просто найти, просто изменить без риска повредить логику класса. При наследовании мы можем их переопределять и тем самым переопределять зависимости.</p>
<p>Но все же, нашему классу не стоит знать о подробностях создания своих зависимостей, он должен просто использовать их. Как с этим бороться? Необходимо выносить порождающую логику из класса на уровень выше.</p>
<blockquote>
<p>Порождающая логика — код, создающий экземпляры класса или структуры. Другими словами — код, порождающий объекты.</p>
</blockquote>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Armor</span> {
    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>var</span> boots: Boots?
    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>var</span> pants: Pants?

    <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>configure</span>(boots: Boots?, pants: Pants?) {
        <span style=color:#66d9ef>self</span>.boots = boots
        <span style=color:#66d9ef>self</span>.pants = pants
    }
}
</code></pre></div><p>Теперь наш класс <strong>Armor</strong> понятия не имеет как создаются его зависимости, они просто передаются в качестве аргументов. Это дает максимальную гибкость. Мы даже можем заменить классы на протоколы и полностью абстрагироваться от деталей реализации.</p>
<p>Но вот у нашего класса <strong>Knight</strong> дела идут не так хорошо.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Knight</span> {

    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>var</span> armor: Armor?

    <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>preapreForBattle</span>() {
        <span style=color:#66d9ef>self</span>.armor = Armor()
        <span style=color:#66d9ef>let</span> boots = makeBoots()
        <span style=color:#66d9ef>let</span> pants = makePants()
        <span style=color:#66d9ef>self</span>.armor?.make(boots: boots, pants: pants)
    }

    <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>makeBoots</span>() -&gt; Boots {
        <span style=color:#66d9ef>return</span> Boots()
    }

    <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>makePants</span>() -&gt; Pants {
        <span style=color:#66d9ef>return</span> Pants()
    }

}
</code></pre></div><p>Он создает все части своей брони. Можно сказать, наш рыцарь сам себе кузнец.
Это неправильно, рыцари не должны ковать себе броню, не их уровня задача, но как тогда быть? Можно вновь вынести порождающую логику на уровень выше, но тогда класс на вершине графа будет огромной свалкой по созданию зависимостей.</p>
<p>На помощь нам придет другой порождающий паттерн — «фабрика».</p>
<blockquote>
<p>Фабрика (англ. Factory) — объект, создающий другие объекты.</p>
</blockquote>
<p>Мы построим кузницу, в которой будут изготавливаться части брони и собираться в единый комплект.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Forge</span> {
    <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>makeArmor</span>() -&gt; Armor {
        <span style=color:#66d9ef>let</span> armor = Armor()
        armor.boots = makeBoots()
        armor.pants = makePants()
        <span style=color:#66d9ef>return</span> armor
    }

    <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>makeBoots</span>() -&gt; Boots {
        <span style=color:#66d9ef>return</span> Boots()
    }

    <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>makePants</span>() -&gt; Pants {
        <span style=color:#66d9ef>return</span> Pants()
    }
}
</code></pre></div><p>Классы Armor и Knight избавятся от порождающей логики и будут смотреться лаконично.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Armor</span> {
    <span style=color:#66d9ef>var</span> boots: Boots?
    <span style=color:#66d9ef>var</span> pants: Pants?
}

<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Knight</span> {

    <span style=color:#66d9ef>var</span> armor: Armor?

}
</code></pre></div><p>Теперь перед нами встает вопрос: как, где и когда забрать зависимости из «фабрики» и передать нашим классам. А, значит, мы наконец пришли к понятиям DI и SL.</p>
<h2 id=сервис-локатор-sl>Сервис локатор (SL)<a hidden class=anchor aria-hidden=true href=#сервис-локатор-sl>#</a></h2>
<p>Начнем, пожалуй, с этого паттерна. Во-первых, он проще. Во-вторых, многие думают, что это и есть DI, хотя это не так.</p>
<blockquote>
<p>SL (сервис локатор, англ. service locator) — это шаблон проектирования, используемый в разработке программного обеспечения для инкапсуляции процессов, связанных с получением какого-либо сервиса с сильным уровнем абстракции. Этот шаблон использует центральный реестр, известный как «локатор сервисов», который по запросу возвращает информацию (как правило, это объекты), необходимую для выполнения определенной задачи.</p>
</blockquote>
<p>В чем же его суть? Классу для того, чтобы получить зависимости, в конструкторе передается «фабрика», из которой он сам выбирает, что же ему получить.</p>
<p>В этом случае наши классы будут выглядеть так:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Forge</span> {

    <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>makeArmor</span>() -&gt; Armor {
        <span style=color:#66d9ef>let</span> armor = Armor(forge: <span style=color:#66d9ef>self</span>)
        <span style=color:#66d9ef>return</span> armor
    }

    <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>makeBoots</span>() -&gt; Boots {
        <span style=color:#66d9ef>return</span> Boots()
    }

    <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>makePants</span>() -&gt; Pants {
        <span style=color:#66d9ef>return</span> Pants()
    }
}
</code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Knight</span> {

    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>let</span> forge: Forge
    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>var</span> armor: Armor?

    <span style=color:#66d9ef>init</span>(forge: Forge) {
        <span style=color:#66d9ef>self</span>.forge = forge
        configure()
    }

    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>configure</span>() {
        armor = forge.makeArmor()
    }
}
</code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Armor</span> {

    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>let</span> forge: Forge

    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>var</span> boots: Boots?
    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>var</span> pants: Pants?

    <span style=color:#66d9ef>init</span>(forge: Forge) {
        <span style=color:#66d9ef>self</span>.forge = forge
        configure()
    }

    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>configure</span>() {
        boots = forge.makeBoots()
        pants = forge.makePants()
    }

}
</code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>let</span> forge = Forge()
<span style=color:#66d9ef>let</span> knight = Knight(forge: forge)
</code></pre></div><p>Лично у меня такой подход вызывает двоякое чувство. С одной стороны, порождающая логика находится в «фабрике», с другой стороны, процесс получения зависимостей несколько запутан. Но самый главный недостаток состоит в том, что, глядя на класс, нельзя однозначно определить его зависимости. Он может получить из «фабрики» все что угодно, типичной ошибкой разработки является создание одной такой «фабрики» на все приложение. При этом «фабрика» превращается в огромную свалку барахла и порождает искушение доставать внутри классов то, что им на самом деле не нужно. У классов пропадает контакт, ограничения.</p>
<p>Можно представить, что нашему рыцарю подарили сундук с сокровищами, из которого он может достать необходимую ему броню, но в довесок никто не помешает ему набрать ненужных украшений.
Именно по этой причине этот паттерн пересек черту добра и зла и превратился в антипаттерн. Если у вас есть выбор между DI и SL, всегда выбирайте DI.</p>
<h2 id=di>DI<a hidden class=anchor aria-hidden=true href=#di>#</a></h2>
<p>Вторым способом доставки зависимостей к классам является DI. В настоящее время это наиболее распространенный паттерн. Он настолько популярен, что в мире бэкенда все нормальные фреймворки поддерживают его из коробки. Нам, к сожалению, так не повезло.</p>
<p>Суть этого паттерна заключается в том, что зависимости внедряются в класс извне, при этом граф зависимостей строится внутри DI контейнера, который является «фабрикой» или набором «фабрик».</p>
<p>Наши классы при этом выглядят так:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Armor</span> {
    <span style=color:#66d9ef>var</span> boots: Boots?
    <span style=color:#66d9ef>var</span> pants: Pants?
}

<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Knight</span> {
    <span style=color:#66d9ef>var</span> armor: Armor?
}

<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Forge</span> {

    <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>makeArmor</span>() -&gt; Armor {
        <span style=color:#66d9ef>let</span> armor = Armor()
        armor.boots = makeBoots()
        armor.pants = makePants()
        <span style=color:#66d9ef>return</span> armor
    }

    <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>makeBoots</span>() -&gt; Boots {
        <span style=color:#66d9ef>return</span> Boots()
    }

    <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>makePants</span>() -&gt; Pants {
        <span style=color:#66d9ef>return</span> Pants()
    }

}
</code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Garrison</span> {
    <span style=color:#66d9ef>lazy</span> <span style=color:#66d9ef>var</span> forge: Forge = {
        <span style=color:#66d9ef>return</span> Forge()
    }()

    <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>makeKnight</span>() -&gt; Knight {
        <span style=color:#66d9ef>let</span> knight = Knight()
        knight.armor = forge.makeArmor()
        <span style=color:#66d9ef>return</span> knight
    }
}
</code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>let</span> garrison = Garrison()
<span style=color:#66d9ef>let</span> knight = garrison.makeKnight()
</code></pre></div><p>В данном случае классы выглядят чистыми, в них полностью отсутствует порождающая логика. Всю ответственность по сборке на себя взяли две «фабрики»: Garrison и Forge. При желании количество этих «фабрик» можно увеличивать, чтобы не допускать разрастания классов. Хорошей практикой является создание «фабрики», ответственной за создание каких-либо родственных объектов. Например, эта «фабрика» может создать сервисы, контроллеры для конкретной user story.</p>
<p>При этом наш рыцарь наконец закончил заниматься не подобающими его статусу вещами, за его амуницию отвечает оруженосец, а рыцарь может сосредоточиться на поединках и принцессах.
На этом можно было бы закончить, но стоит поговорить о некоторых аспектах DI и доступных на данный момент фреймворках.</p>
<h2 id=типы-di>Типы DI<a hidden class=anchor aria-hidden=true href=#типы-di>#</a></h2>
<p>Initializer Injection — внедрение зависимостей через конструктор. Этот подход используется в случае, когда класс не может существовать без своих зависимостей, но даже если это не так, то его можно использовать для более явного определения контракта класса. Если все зависимости объявлены в качестве аргументов конструктора, определить их проще простого. Но не стоит увлекаться, если у класса десяток зависимостей, то лучше не передавать их в конструкторе (а еще лучше разобраться, зачем вашему классу столько зависимостей).</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Armor</span> {
    <span style=color:#66d9ef>let</span> boots: Boots
    <span style=color:#66d9ef>let</span> pants: Pants

    <span style=color:#66d9ef>init</span>(boots: Boots, pants: Pants) {
        <span style=color:#66d9ef>self</span>.boots = boots
        <span style=color:#66d9ef>self</span>.pants = pants
    }
}

<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Forge</span> {

    <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>makeArmor</span>() -&gt; Armor {
        <span style=color:#66d9ef>let</span> boots = makeBoots()
        <span style=color:#66d9ef>let</span> pants = makePants()
        <span style=color:#66d9ef>let</span> armor = Armor(boots: boots, pants: pants)

        <span style=color:#66d9ef>return</span> armor
    }

    <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>makeBoots</span>() -&gt; Boots {
        <span style=color:#66d9ef>return</span> Boots()
    }

    <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>makePants</span>() -&gt; Pants {
        <span style=color:#66d9ef>return</span> Pants()
    }

}
</code></pre></div><p>Property Injection — внедрение зависимостей через свойства. Этот способ используется, когда у класса имеются необязательные зависимости, без которых он может обойтись, или когда зависимости могут изменяться не только на этапе инициализации объекта.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Armor</span> {
    <span style=color:#66d9ef>var</span> boots: Boots?
    <span style=color:#66d9ef>var</span> pants: Pants?
}

<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Forge</span> {

    <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>makeArmor</span>() -&gt; Armor {
        <span style=color:#66d9ef>let</span> armor = Armor()
        armor.boots = makeBoots()
        armor.pants = makePants()
        <span style=color:#66d9ef>return</span> armor
    }

    <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>makeBoots</span>() -&gt; Boots {
        <span style=color:#66d9ef>return</span> Boots()
    }

    <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>makePants</span>() -&gt; Pants {
        <span style=color:#66d9ef>return</span> Pants()
    }

}
</code></pre></div><p>Method Injection — внедрение зависимостей через метод. Этот способ очень похож на Property Injection, но с его помощью можно внедрить временную зависимость только на момент выполнения какого-либо действия или более тесно связать внедрение зависимости с логикой класса.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Knight</span> {
    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>var</span> armor: Armor?

    <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>winTournament</span>(armor: Armor) {
        <span style=color:#66d9ef>self</span>.armor = armor
        defeatEnemy()
        seducePrincess()
        <span style=color:#66d9ef>self</span>.armor = <span style=color:#66d9ef>nil</span>
    }

    <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>defeatEnemy</span>() {}

    <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>seducePrincess</span>() {}
}

<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Garrison</span> {
    <span style=color:#66d9ef>lazy</span> <span style=color:#66d9ef>var</span> forge: Forge = {
        <span style=color:#66d9ef>return</span> Forge()
    }()

    <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>makeKnight</span>() -&gt; Knight {
        <span style=color:#66d9ef>let</span> knight = Knight()
        <span style=color:#66d9ef>return</span> knight
    }
}

<span style=color:#66d9ef>let</span> garrison = Garrison()
<span style=color:#66d9ef>let</span> knight = garrison.makeKnight()

<span style=color:#66d9ef>let</span> armor = garrison.forge.makeArmor()
knight.winTournament(armor: armor)
</code></pre></div><p>По моим наблюдениям наиболее распространенными типами являются Initializer Injection и Property Injection, реже используется Method Injection. И хотя я описал типичные случаи выбора того или иного типа, надо помнить, что Swift является очень гибким языком, предоставляя больше возможностей для выбора типа. Так, например, даже имея необязательные зависимости, можно реализовать конструктор с опциональными аргументами и nil по умолчанию. В таком случае можно использовать Initializer Injection вместо Property Injection. В любом случае это компромисс, который может улучшить или ухудшить ваш код, и выбор остается за вами.</p>
<h2 id=dip>DIP<a hidden class=anchor aria-hidden=true href=#dip>#</a></h2>
<p>Простое использование IoC, как в примерах выше, само по себе приносит неплохие дивиденды, но можно пойти дальше и добиться соблюдения принципа DIP из SOLID. Для этого мы закроем зависимости протоколами, и только «фабрики» будут знать, какая же конкретно кроется реализация за этим протоколом.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Knight</span> {
    <span style=color:#66d9ef>var</span> armor: AbstractArmor?
}

<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Forge</span> {

    <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>makeArmor</span>() -&gt; AbstractArmor {
        <span style=color:#66d9ef>let</span> armor = Armor()
        armor.boots = makeBoots()
        armor.pants = makePants()
        <span style=color:#66d9ef>return</span> armor
    }

    <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>makeBoots</span>() -&gt; Boots {
        <span style=color:#66d9ef>return</span> Boots()
    }

    <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>makePants</span>() -&gt; Pants {
        <span style=color:#66d9ef>return</span> Pants()
    }

}
</code></pre></div><p>В этом случае мы можем без проблем подменять реализацию брони на альтернативную.</p>
<p>SOLID лежит за пределами данной статьи, тем не менее, если вы не знаете, что это такое лучше ознакомиться с этим набором принципов. Можно начать с неплохой <a href=https://habrahabr.ru/post/348286/>вводной статьи</a>, продолжить чтением соответствующих глав в <a href=https://www.ozon.ru/context/detail/id/5800704/>этой книге</a>.</p>
<h2 id=области-видимости>Области видимости<a hidden class=anchor aria-hidden=true href=#области-видимости>#</a></h2>
<p>Само по себе управление областью видимости объектов не является частью IoC концепции, это скорее детали ее реализации, но тем не менее это очень мощный механизм, который позволяет отказаться от синглтонов и решить другие проблемы с общими зависимостями. Область видимости определяет, как долго будет жить зависимость, созданная внутри «фабрики», будет ли оно создаваться каждый раз заново или сохраняться после первого создания и просто передаваться по ссылке.</p>
<p>Так как области видимости не описаны в паттернах, каждый реализует и именует их как считает нужным. Мы рассмотрим два наиболее часто используемых типа.</p>
<p>Стандартная область видимости — это то поведение, какое мы реализовали во всех примерах выше. «Фабрика» создает объект, отдает его и забывает о его существовании. При повторном вызове фабричного метода будет создан новый объект.</p>
<p>Область видимости контейнера — это поведение схожее с синглтоном. При первом вызове фабричного метода создается новый объект, затем «фабрика» сохраняет ссылку на него и возвращает как результат работы фабричного метода, при всех остальных вызовах метода новый объект не создается, а возвращается ссылка на первый объект.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Forge</span> {
    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>var</span> armor: AbstractArmor?

    <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>makeArmor</span>() -&gt; AbstractArmor {
        <span style=color:#75715e>// Если броня уже создана ранее вернеем ее</span>
        <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> armor = <span style=color:#66d9ef>self</span>.armor { <span style=color:#66d9ef>return</span> armor }
        <span style=color:#66d9ef>let</span> armor = Armor()
        armor.boots = makeBoots()
        armor.pants = makePants()
        <span style=color:#66d9ef>self</span>.armor = armor
        <span style=color:#66d9ef>return</span> armor
    }

    <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>makeBoots</span>() -&gt; Boots {
        <span style=color:#66d9ef>return</span> Boots()
    }

    <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>makePants</span>() -&gt; Pants {
        <span style=color:#66d9ef>return</span> Pants()
    }

}
</code></pre></div><p>Как вы видите, в примере выше броня создается только один раз, во всех остальных случаях возвращается ранее созданный экземпляр. Аналогично синглтону, мы всегда будем работать с одним и тем же экземпляром класса, при этом без глобальной области видимости.</p>
<h2 id=плюсы-и-минусы>Плюсы и минусы<a hidden class=anchor aria-hidden=true href=#плюсы-и-минусы>#</a></h2>
<p>Как и любые другие принципы в программировании IoC не является серебряной пулей, у него есть свои плюсы:</p>
<ul>
<li>Уменьшает связанность классов;</li>
<li>Проще переиспользовать классы;</li>
<li>Более компактные классы за счет выноса поражающей логики;</li>
<li>Инкапсулирует порождающую логику, что делает ее рефакторинг проще;</li>
<li>Скрывает реализацию;</li>
<li>Упрощает замену реализации;</li>
<li>Упрощает тестирование: подменив “фабрики”, можно заменить зависимости моками;</li>
<li>Позволяет шарить объекты в приложении без использования синглтона.</li>
</ul>
<p>И минусы:</p>
<ul>
<li>Увеличивает количество классов при сокрытии реализации за абстракцией;</li>
<li>Увеличивает время погружения в проект;</li>
<li>Легко может привести к оверинжинирингу.</li>
</ul>
<p>Хотя мое мнение что, главный и единственный минус — это оверинжиниринг в результате безудержного желания четко следовать принципу DIP. Часто можно увидеть, как создается пачка классов, закрывается вдвое более пухлой пачкой протоколов, и это добро проксирует вызов одного метода.</p>
<p>Если вы подумаете, что хорошо бы создать протокол, сначала подумайте зачем. У вас есть взаимозаменяемые классы, которые необходимо спрятать за общим интерфейсом? Вам требуется сокрыть реализацию, а нельзя обойтись просто модификатором доступа? Для тестирования? Может, для мока хватит простого наследования?</p>
<h2 id=подводя-итог>Подводя итог<a hidden class=anchor aria-hidden=true href=#подводя-итог>#</a></h2>
<p>На мой взгляд, соблюдение принципов IoC является обязательным условием при разработке проекта, который будет поддерживаться, а не просто забыт после релиза. Если мы заглянем за пределы iOS-песочницы, то обнаружим, что в android-разработке использование DI, воплотившегося в виде фреймворка dagger, стало почти стандартом. В мире бэкенда, например, в spring управление зависимостями лежит в основе всей архитектуры фреймворка. Даже php-фреймворки, такие как, например, Laravel призывают использовать DI и предоставляют необходимые инструменты из коробки. В iOS, к сожалению, так и не появилось ни коробочного решения, ни фреймворка, который бы стал стандартом. Да для Objective-C можно считать таковым тайфун, но не для swift.</p>
<p>К счастью, вам необязательно использовать именитый фреймворк. Одной из целей этой статьи как раз было показать, что IoC — это не фрейворк, и то, что если в проекте нет тайфуна, это не значит, что там нет DI. Для реализации IoC в проекте неважно, выберете вы DI или SL, достаточно обычной «фабрики», которую вполне можно написать самому. Такая «фабрика» является самым простым DI контейнером.</p>
</div>
<footer class=post-footer>
<ul class=post-tags>
<li><a href=https://jonfir.github.io/tags/di/>DI</a></li>
<li><a href=https://jonfir.github.io/tags/swift/>Swift</a></li>
<li><a href=https://jonfir.github.io/tags/ios/>iOS</a></li>
</ul>
<nav class=paginav>
<a class=prev href=https://jonfir.github.io/posts/ios-project-structure/>
<span class=title>« Предыдущая</span>
<br>
<span>Структура iOS проекта</span>
</a>
</nav>
<div class=share-buttons>
<a target=_blank rel="noopener noreferrer" aria-label="share Инверсия управления в iOS on twitter" href="https://twitter.com/intent/tweet/?text=%d0%98%d0%bd%d0%b2%d0%b5%d1%80%d1%81%d0%b8%d1%8f%20%d1%83%d0%bf%d1%80%d0%b0%d0%b2%d0%bb%d0%b5%d0%bd%d0%b8%d1%8f%20%d0%b2%20iOS&url=https%3a%2f%2fjonfir.github.io%2fposts%2fioc-ios%2f&hashtags=DI%2cSwift%2ciOS"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Инверсия управления в iOS on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fjonfir.github.io%2fposts%2fioc-ios%2f&title=%d0%98%d0%bd%d0%b2%d0%b5%d1%80%d1%81%d0%b8%d1%8f%20%d1%83%d0%bf%d1%80%d0%b0%d0%b2%d0%bb%d0%b5%d0%bd%d0%b8%d1%8f%20%d0%b2%20iOS&summary=%d0%98%d0%bd%d0%b2%d0%b5%d1%80%d1%81%d0%b8%d1%8f%20%d1%83%d0%bf%d1%80%d0%b0%d0%b2%d0%bb%d0%b5%d0%bd%d0%b8%d1%8f%20%d0%b2%20iOS&source=https%3a%2f%2fjonfir.github.io%2fposts%2fioc-ios%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Инверсия управления в iOS on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fjonfir.github.io%2fposts%2fioc-ios%2f&title=%d0%98%d0%bd%d0%b2%d0%b5%d1%80%d1%81%d0%b8%d1%8f%20%d1%83%d0%bf%d1%80%d0%b0%d0%b2%d0%bb%d0%b5%d0%bd%d0%b8%d1%8f%20%d0%b2%20iOS"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Инверсия управления в iOS on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fjonfir.github.io%2fposts%2fioc-ios%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Инверсия управления в iOS on whatsapp" href="https://api.whatsapp.com/send?text=%d0%98%d0%bd%d0%b2%d0%b5%d1%80%d1%81%d0%b8%d1%8f%20%d1%83%d0%bf%d1%80%d0%b0%d0%b2%d0%bb%d0%b5%d0%bd%d0%b8%d1%8f%20%d0%b2%20iOS%20-%20https%3a%2f%2fjonfir.github.io%2fposts%2fioc-ios%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Инверсия управления в iOS on telegram" href="https://telegram.me/share/url?text=%d0%98%d0%bd%d0%b2%d0%b5%d1%80%d1%81%d0%b8%d1%8f%20%d1%83%d0%bf%d1%80%d0%b0%d0%b2%d0%bb%d0%b5%d0%bd%d0%b8%d1%8f%20%d0%b2%20iOS&url=https%3a%2f%2fjonfir.github.io%2fposts%2fioc-ios%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg>
</a>
</div>
</footer><div id=disqus_thread></div>
<script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return}var b=document,a=b.createElement('script');a.async=!0,a.src='//jonfir.disqus.com/embed.js',a.setAttribute('data-timestamp',+new Date),(b.head||b.body).appendChild(a)})()</script>
<noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript>
<a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a>
</article>
</main>
<footer class=footer>
<span>&copy; 2022 <a href=https://jonfir.github.io>JonFir</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
<script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerText='копировать';function d(){a.innerText='скопировано!',setTimeout(()=>{a.innerText='копировать'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script>
</body>
</html>